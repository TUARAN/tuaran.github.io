(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{557:function(s,n,a){"use strict";a.r(n);var t=a(2),e=Object(t.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("前面已经带来 2 篇关于滑动窗口的掘文，传送门：")]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://juejin.cn/post/7025475800623218702",target:"_blank",rel:"noopener noreferrer"}},[s._v("《温故知新 —— Sliding Window》"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.cn/post/7026259253866266654",target:"_blank",rel:"noopener noreferrer"}},[s._v("《辛辣天塞！滑动窗口之【和的最大值】&【最大值集合】》"),a("OutboundLink")],1)])]),s._v(" "),a("p",[s._v("前文说到，即使都是窗口滑动，但“怎么滑”，滑动后“怎么做”，里面就存在很大的解题思路的差异！")]),s._v(" "),a("p",[s._v("本篇继续来探索、发现、记录这个差异~ 当然也不能忘了解题中的感受分享~")]),s._v(" "),a("h2",{attrs:{id:"滑动窗口中位数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口中位数"}},[s._v("#")]),s._v(" 滑动窗口中位数")]),s._v(" "),a("blockquote",[a("p",[s._v("题目：给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。")])]),s._v(" "),a("p",[s._v("中位数：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数，例如：\n\n[2,3,4]，中位数是 3\n[2,3]，中位数是 (2 + 3) / 2 = 2.5\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("示例：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。\n\n窗口位置                      中位数\n---------------               -----\n[1  3  -1] -3  5  3  6  7       1\n 1 [3  -1  -3] 5  3  6  7      -1\n 1  3 [-1  -3  5] 3  6  7      -1\n 1  3  -1 [-3  5  3] 6  7       3\n 1  3  -1  -3 [5  3  6] 7       5\n 1  3  -1  -3  5 [3  6  7]      6\n\n因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("p",[s._v("有了前面两篇文章的基础，我们知道了：问题的关键不在于窗口滑动，而在于“滑动的过程中怎么去求这个中位数？”")]),s._v(" "),a("p",[s._v("暴力求中位数：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 计算中位数---奇数情况\nfunction calMedianOdd(sortedWindow) {\n    const len = sortedWindow.length;\n    return sortedWindow[Math.floor(len / 2)];\n}\n// 计算中位数---偶数情况\nfunction calMedianEven(sortedWindow) {\n    const len = sortedWindow.length;\n    return (sortedWindow[Math.floor(len / 2)] +\n        sortedWindow[Math.floor(len / 2) - 1]) / 2;\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("这样，不出意外，会报错："),a("code",[s._v("超出时间限制")]),s._v("，因为每次发生窗口滑动了，还要进行排序，时间复杂度大于 O(n * k)，还取决于排序算法；")]),s._v(" "),a("p",[s._v("有没有什么办法在滑动窗口的时候能利用上一个滑窗的状态？")]),s._v(" "),a("p",[s._v("答案肯定是“有的”，不然就全剧终了~")]),s._v(" "),a("p",[s._v("有一个很重要的条件："),a("strong",[s._v("每次移动时，在删除左边界元素与加入右边界元素之前，窗口内的内容必然有序；")])]),s._v(" "),a("p",[s._v("所以，在我们初始化排完顺序之后，发生第一次窗口的滑动时，希望找到右边界元素插入的正确位置（splice），以保障插入后直接就是有序的了，不用再排序了；")]),s._v(" "),a("p",[s._v("于是乎：问题变成了 —— 在有序数列中找到一个位置，【二分法】登场！")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 二分搜索\nfunction binarySearch(sortedArr, target) {\n    // 这里的搜索区间是左闭右开\n    let left = 0;\n    let right = sortedArr.length;\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        // 不能舍去mid\n        if (sortedArr[mid] > target) {\n            right = mid;\n        } else if (sortedArr[mid] <= target) {\n            left = mid + 1;\n        }\n    }\n    return right;\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("p",[s._v("全部的算法就不贴了，思路已经有了，具体实现就自己敲敲打打吧~")]),s._v(" "),a("p",[s._v("小结：滑动窗口的重点不是使窗口滑动就完事了，重点是下一窗口的滑动怎样利用上一窗口的“特性”，比如：有序；")]),s._v(" "),a("h2",{attrs:{id:"滑动魔方"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#滑动魔方"}},[s._v("#")]),s._v(" 滑动魔方")]),s._v(" "),a("blockquote",[a("p",[s._v("题目：在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示.一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换.")]),s._v(" "),a("p",[s._v("最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。")]),s._v(" "),a("p",[s._v("给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。")])]),s._v(" "),a("p",[s._v("示例：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("输入：board = [[1,2,3],[4,0,5]]\n输出：1\n解释：交换 0 和 5 ，1 步完成\n\n输入：board = [[1,2,3],[5,4,0]]\n输出：-1\n解释：没有办法完成谜板\n\n输入：board = [[4,1,2],[5,0,3]]\n输出：5\n解释：\n最少完成谜板的最少移动次数是 5 ，\n一种移动路径:\n尚未移动: [[4,1,2],[5,0,3]]\n移动 1 次: [[4,1,2],[0,5,3]]\n移动 2 次: [[0,1,2],[4,5,3]]\n移动 3 次: [[1,0,2],[4,5,3]]\n移动 4 次: [[1,2,0],[4,5,3]]\n移动 5 次: [[1,2,3],[4,5,0]]\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br")])]),a("p",[s._v("哇，这个读完题就能感觉到难度，有点像是玩魔方，把一个数组丢到一个算法里进行“旋转”，最后得出一共走了几步；")]),s._v(" "),a("p",[s._v("解题关键词：广度优先搜索；")]),s._v(" "),a("p",[s._v("其实思路就是穷举，没走一步，列出所有变化，然后与目标值匹配，如果没有，再多走一步，然后再穷举、匹配，搜索完成后，还没有匹配的，则返回 -1；")]),s._v(" "),a("p",[s._v("本题当中，由于是一个二维数组，所以，注意条件是 "),a("em",[s._v("与一个相邻的数字（上下左右）进行交换")]),s._v(" ；")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca59cd90da224e468c5cc30dc1973d1a~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),s._v(" "),a("p",[s._v("例如 0 所在的位置是 x，对于每一个与 x 相邻的位置 y，我们将 status[x] 与 status[y] 进行交换，即等同于进行了一次操作；")]),s._v(" "),a("p",[s._v("核心代码：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("...\n// 枚举 status 通过一次交换操作得到的状态\n    const get = (status) => {\n        const ret = [];\n        const array = Array.from(status);\n        const x = status.indexOf('0');\n        for (const y of neighbors[x]) {\n            [array[x], array[y]] = [array[y], array[x]];\n            ret.push(array.join(''));\n            [array[x], array[y]] = [array[y], array[x]];\n        }\n        return ret;\n    }\n...\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("p",[s._v("本篇还有另一种思路：很久前写过一篇"),a("a",{attrs:{href:"https://juejin.cn/post/6905692756190953480",target:"_blank",rel:"noopener noreferrer"}},[s._v("《狄克斯特拉算法》"),a("OutboundLink")],1),s._v("，应该能给到一些启发~~")]),s._v(" "),a("hr"),s._v(" "),a("p",[s._v("OK，至此我们前前后后通过滑动窗口认识了：单调队列、二分法、广度优先搜索；有一说一，滑动窗口，有点东西！")]),s._v(" "),a("blockquote",[a("p",[s._v("我是掘金安东尼，公众号同名，输出暴露输入，技术洞见生活，下次再会~~")])])])}),[],!1,null,null,null);n.default=e.exports}}]);