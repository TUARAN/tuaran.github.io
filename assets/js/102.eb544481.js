(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{599:function(n,a,e){"use strict";e.r(a);var t=e(2),r=Object(t.a)({},(function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("起初本瓜看到"),e("code",[n._v("【单子】说白了不过就是【自函子范畴】上的一个【幺半群】而已？")]),n._v("这句话的时候，还以为自己在看量子力学的量子纠缠相关内容，"),e("strong",[n._v("单子、函子")]),n._v("、粒子、玻色子、费米子、绝绝子。。。")]),n._v(" "),e("p",[n._v("正好最近又看到一篇"),e("a",{attrs:{href:"https://www.zhihu.com/question/29620539",target:"_blank",rel:"noopener noreferrer"}},[n._v("《怎样理解“范畴”？》"),e("OutboundLink")],1),n._v("，解释 "),e("strong",[n._v("“范畴”")]),n._v(" 都这么费劲？表示脑细胞已经不够用了。。。")]),n._v(" "),e("p",[n._v("至于 "),e("strong",[n._v("“幺半群”")]),n._v("？是打麻将吗。。。")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b681c1ad02704105bb2bce3f91d10030~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),n._v(" "),e("p",[n._v("好家伙~ 最后，你告诉我这句话是关于函数式编程 Monad 的解释，牛你是真滴牛！")]),n._v(" "),e("ul",[e("li",[n._v("怕生词概念的同学先别慌，先告诉你 Monad 和 Promise 很像，增点亲切感；😁")])]),n._v(" "),e("h2",{attrs:{id:"浅尝-monad"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浅尝-monad"}},[n._v("#")]),n._v(" 浅尝 Monad")]),n._v(" "),e("p",[n._v("在函数式编程中我们一直强调："),e("strong",[n._v("纯函数、纯函数、纯函数！无副作用，无副作用，无副作用！")])]),n._v(" "),e("p",[n._v("但是，要求总写没有任何副作用的纯函数是几乎不可能的；")]),n._v(" "),e("p",[n._v("HTTP 请求、修改函数外的数据、输出数据到屏幕或控制台、DOM查询/操作、Math.random()、获取当前时间等，这些操作都会使函数产生副作用，导致我们跟踪数据状态困难、代码不易读；")]),n._v(" "),e("p",[n._v("又但是！我们即使不能一直写纯纯的纯函数，不过，"),e("strong",[n._v("尽可能把这些副作用操作放在最后去执行（延迟处理、惰性处理）")]),n._v("，这也是函数式编程书写纯函数原则之一！")]),n._v(" "),e("p",[n._v("而实现这种做法靠的就是 Monad！")]),n._v(" "),e("p",[n._v("直接上代码，看看 Monad 在实际应用中是怎么写的：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('var fs = require("fs");\n\n// 纯函数，传入 filename，返回 Monad 对象\nvar readFile = function (filename) {\n  // 副作用函数：读取文件\n  const readFileFn = () => {\n    return fs.readFileSync(filename, "utf-8");\n  };\n  return new Monad(readFileFn);\n};\n\n// 纯函数，传入 x，返回 Monad 对象\nvar print = function (x) {\n  // 副作用函数：打印日志\n  const logFn = () => {\n    console.log(x);\n    return x;\n  };\n  return new Monad(logFn);\n};\n\n// 纯函数，传入 x，返回 Monad 对象\nvar tail = function (x) {\n  // 副作用函数：返回最后一行的数据\n  const tailFn = () => {\n    return x[x.length - 1];\n  };\n  return new Monad(tailFn);\n};\n\n// 链式操作文件\nconst monad = readFile("./xxx.txt").bind(tail).bind(print);\n// 执行到这里，整个操作都是纯的，因为副作用函数一直被包裹在 Monad 里，并没有执行\nmonad.value(); // 执行副作用函数\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br"),e("span",{staticClass:"line-number"},[n._v("34")]),e("br")])]),e("ul",[e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/306339035",target:"_blank",rel:"noopener noreferrer"}},[n._v("代码来源-孟思行"),e("OutboundLink")],1)])]),n._v(" "),e("p",[n._v("我们用 Monad 将包含副作用函数得操作进行封装，到绑定链式操作的时候，都并没有执行任何副作用操作；")]),n._v(" "),e("p",[n._v("直到最后，调用 "),e("code",[n._v("monad.value()")]),n._v(" 才执行了这些副作用操作；")]),n._v(" "),e("p",[n._v("在外界看来，被 Monad 函数包裹住含副作用的函数，根本就和纯函数是一样一样的，因为：")]),n._v(" "),e("blockquote",[e("p",[n._v("你无法知道一间黑色的房间里面有没有一只黑色的猫；")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1c0567d20064cb8b4d673cd2fecaeb8~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),n._v(" "),e("p",[n._v("在编程开发中，尤其是多人协作中，一个数据要经过各种计算、加入各种逻辑、进行不同线路的变异，最后呈现给消费方；")]),n._v(" "),e("p",[n._v("这个数据的链路"),e("strong",[n._v("越长（多计算）、越多（多分支）、越复杂（多异步）")]),n._v("，数据的"),e("strong",[n._v("元信息越容易丢失")]),n._v("，就像一句话，经过不同人的不同方式转述后，会变得和初始意义相差甚远；")]),n._v(" "),e("p",[n._v("我们试图将计算（函子）和业务输出（链式操作）剥离开来，会让这个“转述”过程更准确、清晰；")]),n._v(" "),e("h2",{attrs:{id:"wiki-中-monad"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#wiki-中-monad"}},[n._v("#")]),n._v(" wiki 中 Monad")]),n._v(" "),e("p",[n._v("没错，上一小节中的 Monad 只说了它的应用示例，此小 bar 来看看它在 wiki 中的【超干】定义：")]),n._v(" "),e("p",[n._v("单子由 3 个部分组成：")]),n._v(" "),e("ul",[e("li",[e("p",[e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%9E%84%E9%80%A0%E5%AD%90",title:"类型构造子",target:"_blank",rel:"noopener noreferrer"}},[n._v("类型构造子"),e("OutboundLink")],1),n._v(" "),e("code",[n._v("M")]),n._v("，建造一个单子类型"),e("code",[n._v("M T")])])]),n._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2",title:"类型转换",target:"_blank",rel:"noopener noreferrer"}},[n._v("类型转换子"),e("OutboundLink")],1),n._v("，经常叫做"),e("strong",[n._v("unit")]),n._v("或"),e("strong",[n._v("return")]),n._v("，将一个对象"),e("code",[n._v("x")]),n._v("嵌入到单子中：")]),n._v(" "),e("p",[e("code",[n._v("unit(x) :: T -> M T")])])]),n._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E7%BB%84%E5%90%88%E5%AD%90",title:"组合子",target:"_blank",rel:"noopener noreferrer"}},[n._v("组合子"),e("OutboundLink")],1),n._v("，典型的叫做"),e("strong",[n._v("bind")]),n._v("（"),e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E7%BA%A6%E6%9D%9F%E5%8F%98%E9%87%8F",title:"约束变量",target:"_blank",rel:"noopener noreferrer"}},[n._v("约束变量"),e("OutboundLink")],1),n._v("的那个bind），并表示为"),e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E4%B8%AD%E7%BC%80%E8%A1%A8%E7%A4%BA%E6%B3%95",title:"中缀表示法",target:"_blank",rel:"noopener noreferrer"}},[n._v("中缀算子"),e("OutboundLink")],1),e("code",[n._v(">>=")]),n._v("，去包装一个单体变量，接着把它插入到一个单体函数/表达式之中，结果为一个新的单体值：")]),n._v(" "),e("p",[e("code",[n._v("(mx >>= f) :: (M T, T -> M U) -> M U")])])])]),n._v(" "),e("p",[n._v("同时，这 3 个组成部分还需遵循 3 个定律：")]),n._v(" "),e("ul",[e("li",[e("p",[e("code",[n._v("unit")]),n._v("是bind的"),e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BD%8D%E5%85%83",title:"单比特",target:"_blank",rel:"noopener noreferrer"}},[n._v("左单比特"),e("OutboundLink")],1),n._v("：")]),n._v(" "),e("p",[e("code",[n._v("unit(a) >>= λx -> f(x) ↔ f(a)")])])]),n._v(" "),e("li",[e("p",[e("code",[n._v("unit")]),n._v("也是bind的右单比特:")]),n._v(" "),e("p",[e("code",[n._v("ma >>= λx -> unit(x) ↔ ma")])])]),n._v(" "),e("li",[e("p",[n._v("bind本质上符合"),e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E7%BB%93%E5%90%88%E5%BE%8B",title:"结合律",target:"_blank",rel:"noopener noreferrer"}},[n._v("结合律"),e("OutboundLink")],1),n._v("：")]),n._v(" "),e("p",[e("code",[n._v("ma >>= λx -> (f(x) >>= λy -> g(y)) ↔ (ma >>= λx -> f(x)) >>= λy -> g(y)")])])])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08b0d98c444043e498a198d32db28aaa~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),n._v(" "),e("p",[n._v("没看懂？确实难懂！本瓜好奇：当我不懂 A 时，有人用 A` 来解释 A，但我又不懂 A`，然后再用 A_ 来解释 A`，还是没懂，之后，再用 A/ 、A·、A+ ......来一层套一层解释，当这个解释线拉的足够长的时候，是否还能做到：有效解释？🐶")]),n._v(" "),e("p",[n._v("可以直接这样理解：Monad 是一种特殊的数据结构，它能把值进行"),e("strong",[n._v("包装")]),n._v("，然后"),e("strong",[n._v("链接")]),n._v("执行；王垠在"),e("a",{attrs:{href:"https://link.jianshu.com/?t=http://www.yinwang.org/blog-cn/2013/03/31/purely-functional",target:"_blank",rel:"noopener noreferrer"}},[n._v("《对函数式语言的误解》"),e("OutboundLink")],1),n._v("中准确了描述了 Monad 本质：")]),n._v(" "),e("blockquote",[e("p",[n._v("Monad 本质是使用类型系统的“重载”（overloading），把这些多出来的参数和返回值，掩盖在类型里面。这就像把乱七八糟的电线塞进了接线盒似的，虽然表面上看起来清爽了一些，底下的复杂性却是不可能消除的。")])]),n._v(" "),e("p",[n._v("所以，底下的复杂性是自然。")]),n._v(" "),e("h2",{attrs:{id:"promise-和-monad"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-和-monad"}},[n._v("#")]),n._v(" Promise 和 Monad")]),n._v(" "),e("p",[n._v("我们尝试用 JS 来模拟最基本的 Monad：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Monad {\n  value = "";\n  // 构造函数\n  constructor(value) {\n    this.value = value;\n  }\n  // unit，把值装入 Monad 构造函数中\n  unit(value) {\n    this.value = value;\n  }\n  // bind，把值转换成一个新的 Monad\n  bind(fn) {\n    return fn(this.value);\n  }\n}\n\n// 满足 x-> M(x) 格式的函数\nfunction add1(x) {\n  return new Monad(x + 1);\n}\n// 满足 x-> M(x) 格式的函数\nfunction square(x) {\n  return new Monad(x * x);\n}\n\n// 接下来，我们就能进行链式调用了\nconst a = new Monad(2)\n     .bind(square)\n     .bind(add1);\n     //...\n\nconsole.log(a.value === 5); // true\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br")])]),e("ul",[e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/306339035",target:"_blank",rel:"noopener noreferrer"}},[n._v("代码来源-孟思行"),e("OutboundLink")],1)])]),n._v(" "),e("p",[n._v("那为什么我们最开始说 Monad 和 Promise 很像呢？")]),n._v(" "),e("p",[n._v("可以看到，确实很像：")]),n._v(" "),e("ul",[e("li",[n._v("Promise 也是构造函数；")]),n._v(" "),e("li",[n._v("Promise.Resolve ，相当于 Monad unit，用于包装返回值；")]),n._v(" "),e("li",[n._v("Promise.prototype.then 相当于 Monad bind，用于链接执行；")])]),n._v(" "),e("p",[n._v("Promise 等效于把函数进行包装，Promise.resolve 等效于把这个包装进行拆开，将为一个普通的值；")]),n._v(" "),e("p",[n._v("不过，Promise 不都是 Monad，示例🌰")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904afdf3c79d4e779a5c2fbe7824fd27~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),n._v(" "),e("p",[e("code",[n._v("Promise.resolve")]),n._v(" 传入的是 "),e("code",[n._v("Promise.resovle(1)")]),n._v(" 这个 Promise 对象时，已经做了计算，"),e("code",[n._v("p.then")]),n._v(" 失效；")]),n._v(" "),e("p",[n._v("关于 Promise 和 Monad 再引用一个很棒的解释（建议重点阅读）：")]),n._v(" "),e("blockquote",[e("p",[n._v("纯函数不能有副作用，所以无法与外部进行 IO 操作，不能存在 a -> IO 或 IO -> a 这种操作，必须为 IO -> IO（Promise -> Promise），也就是必须为「自函子」，async 函数中都是自函子映射，也就是一个「自函子范畴」，那么相对的「幺半群」就是Promise了。")])]),n._v(" "),e("h2",{attrs:{id:"阶段小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#阶段小结"}},[n._v("#")]),n._v(" 阶段小结")]),n._v(" "),e("p",[n._v("函数式编程中，处处都是惰性思维的体现；\nMonad 也是惰性计算的实践之一；至于标题中的这句话："),e("code",[n._v("【单子】说白了不过就是【自函子范畴】上的一个【幺半群】而已？")]),n._v("咱们也用惰性思维去思考：现在很难理解，那我是必须要现在去理解吗？如果不是，那就放到后面需要去理解的时候再去理解吧~~ 不过至少，也要勾勒一下 Monad 和 Promise 关系的大致轮廓；Promise 是 JS 人的浪漫！Monad 是函数式编程的浪漫！")]),n._v(" "),e("p",[n._v("后续还会带来各类单子介绍，建议结合"),e("a",{attrs:{href:"https://juejin.cn/column/6960836897669120036",target:"_blank",rel:"noopener noreferrer"}},[n._v("专栏"),e("OutboundLink")],1),n._v("内容，联系前后食用~")]),n._v(" "),e("p",[n._v("以上。")]),n._v(" "),e("p",[n._v("撰文不易，点赞鼓励👍👍👍")]),n._v(" "),e("blockquote",[e("p",[n._v("我是掘金安东尼，公众号同名，输出暴露输入，技术洞见生活，再会！")])]),n._v(" "),e("h2",{attrs:{id:"推荐阅读"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#推荐阅读"}},[n._v("#")]),n._v(" 推荐阅读")]),n._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"http://www.yinwang.org/blog-cn/2013/03/31/purely-functional",target:"_blank",rel:"noopener noreferrer"}},[n._v("函数式语言的宗教"),e("OutboundLink")],1)]),n._v(" "),e("li",[e("a",{attrs:{href:"https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("图解 Monad"),e("OutboundLink")],1)]),n._v(" "),e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/56810671",target:"_blank",rel:"noopener noreferrer"}},[n._v("JS 中 Monad"),e("OutboundLink")],1)]),n._v(" "),e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/306339035",target:"_blank",rel:"noopener noreferrer"}},[n._v("学习函数式编程 Monad"),e("OutboundLink")],1)]),n._v(" "),e("li",[e("a",{attrs:{href:"https://gist.github.com/clausreinke/5984869",target:"_blank",rel:"noopener noreferrer"}},[n._v("monadic.ts"),e("OutboundLink")],1)]),n._v(" "),e("li",[e("a",{attrs:{href:"https://www.zhihu.com/question/22291305/answer/730890410",target:"_blank",rel:"noopener noreferrer"}},[n._v("如何解释 Haskell 中的单子（Monad）"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);