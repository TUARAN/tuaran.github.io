(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{574:function(e,n,t){"use strict";t.r(n);var a=t(2),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("hr"),e._v(" "),t("p",[e._v("上一篇"),t("a",{attrs:{href:"https://juejin.cn/post/7034323334611353630",target:"_blank",rel:"noopener noreferrer"}},[e._v("《大小堆解决【数据流中位数】问题，nice 图解~》"),t("OutboundLink")],1),e._v("讲到了 AVL 树，即："),t("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91",title:"自平衡二叉查找树",target:"_blank",rel:"noopener noreferrer"}},[e._v("自平衡二叉查找树"),t("OutboundLink")],1),e._v("；")]),e._v(" "),t("p",[e._v("此“树”不是一般的“树”！它在 1962 年被发明，作者是 "),t("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA",title:"格奥尔吉·阿杰尔松-韦利斯基",target:"_blank",rel:"noopener noreferrer"}},[e._v("G. M. Adelson-Velsky"),t("OutboundLink")],1),e._v(" 和 "),t("a",{attrs:{href:"https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&action=edit&redlink=1",target:"_blank",rel:"noopener noreferrer"}},[e._v("Evgenii Landis"),t("OutboundLink")],1),e._v("，"),t("strong",[e._v("AVL 树是最早的平衡二叉树实现之一。")])]),e._v(" "),t("p",[e._v("本篇将继续探索 AVL 树基础原理，日拱一卒，冲！")]),e._v(" "),t("p",[e._v("推荐阅读："),t("a",{attrs:{href:"https://adrianmejia.com/self-balanced-binary-search-trees-with-avl-tree-data-structure-for-beginners/#Tree-rotations",target:"_blank",rel:"noopener noreferrer"}},[e._v("Self-balanced Binary Search Trees with AVL in JavaScript"),t("OutboundLink")],1),e._v(" （挖个坑，有空翻译~）")]),e._v(" "),t("h2",{attrs:{id:"avl旋转"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#avl旋转"}},[e._v("#")]),e._v(" AVL旋转")]),e._v(" "),t("p",[e._v("在 AVL 树中，增加和删除元素的操作则可能需要借由一次或多次 "),t("strong",[e._v("树旋转")]),e._v("，以实现树的重新平衡。")]),e._v(" "),t("p",[e._v("所以，AVL树最核心操作就是“AVL 旋转”！")]),e._v(" "),t("p",[e._v("以下 GIF 演示了不断将节点插入AVL树时的情况，包含:")]),e._v(" "),t("ul",[t("li",[e._v("左旋（Left Rotation）")]),e._v(" "),t("li",[e._v("右旋（Right Rotation）")]),e._v(" "),t("li",[e._v("右左旋转（Right-Left Rotation）")]),e._v(" "),t("li",[e._v("左右旋转（Left-Right Rotation）")]),e._v(" "),t("li",[e._v("以及带子树的右旋（Right Rotation with children）")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee5e6ee4e34540d5b5fb4aa1eade3061~tplv-k3u1fbpfcp-watermark.image?",alt:"AVL_Tree_Example.gif"}})]),e._v(" "),t("p",[e._v("安利一个在线动态演示 VAL 树的旋转的网站："),t("a",{attrs:{href:"https://www.cs.usfca.edu/~galles/visualization/AVLtree.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.cs.usfca.edu/~galles/visualization/AVLtree.html"),t("OutboundLink")],1),e._v(" 👍👍👍")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07f30ef41e224a858a17a8411b64ded5~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),e._v(" "),t("p",[e._v("png 示意：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/912c7f2fdaf3490689db1a7144775b11~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),e._v(" "),t("p",[e._v("（图片来源："),t("a",{attrs:{href:"https://zh.wikipedia.org/wiki/AVL%E6%A0%91#/media/File:Tree_Rebalancing.png",target:"_blank",rel:"noopener noreferrer"}},[e._v("wikipedia"),t("OutboundLink")],1),e._v("）")]),e._v(" "),t("p",[t("strong",[e._v("AVL 的操作代价分析：")])]),e._v(" "),t("ol",[t("li",[t("p",[e._v("查找代价：查找效率很好，最坏情况都是O(logN)数量级；")])]),e._v(" "),t("li",[t("p",[e._v("插入代价： AVL必须要保证严格平衡(|bf|<=1)，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。因此，总体上插入操作的代价仍然在O(logN)级别(插入结点需要首先查找插入的位置)；")])]),e._v(" "),t("li",[t("p",[e._v("删除代价：删除必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN)；")])])]),e._v(" "),t("h2",{attrs:{id:"js-实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js-实现"}},[e._v("#")]),e._v(" JS 实现")]),e._v(" "),t("p",[e._v("左单旋：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function roateLeft(AvlNode) {\n        var node = AvlNode.right; // 保存右子节点\n        AvlNode.right = node.left; // node的左子节点连接到AvlNode成为其右子节点\n        node.left = AvlNode; // AvlNode连接到node成为其左子节点\n        return node; // 返回node，连接到AvlNode最初的父节点\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br")])]),t("p",[e._v("右单旋：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function roateRight(AvlNode) {\n        var node = AvlNode.left; // 保存左子节点\n        AvlNode.left = node.right; // 将node的右子节点连接到AvlNode成为其左子节点\n        node.right = AvlNode; // AvlNode连接到node，成为其右子节点\n        return node; // 返回node连接到AvlNode最初的父节点\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br")])]),t("p",[e._v("左-右双旋：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function roateLeftRight(AvlNode) {\n        AvlNode.right = roateLeft(AvlNode.right); // 对右子节点做左单旋\n        return roateRight(AvlNode); // 做右单旋\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br")])]),t("p",[e._v("右-左双旋：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function roateRightLeft(AvlNode) {\n        AvlNode.left = roateRight(AvlNode.left); // 对左子节点做右单旋\n        return roateLeft(AvlNode); // 做左单旋\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br")])]),t("p",[e._v("获取树高度的函数：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function getAvlTreeHeight(node) {\n        if (node == null) {\n            // node不存在返回0\n            return 0;\n        } else {\n            var leftHeight = getAvlTreeHeight(node.left);\n            var rightHeight = getAvlTreeHeight(node.right);\n            // 返回左子树、右子树中的最大高度\n            return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;\n        }\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br")])]),t("p",[e._v("实现平衡树的函数：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function balance(node) {\n    if (node == null) {\n        return node;\n    }\n    // 左子树高度比右子树高度大1以上\n    if (getAvlTreeHeight(node.left) - getAvlTreeHeight(node.right) > 1) {\n        if (getAvlTreeHeight(node.left.left) >= getAvlTreeHeight(node.left.right)) {\n            // 如果左子树的左子树高度大于等于左子树的右子树高度\n            // 直接进行右单旋\n            node = roateRight(node);\n        } else {\n            // 否则需要右-左双旋\n            node = roateRightLeft(node);\n        }\n        // 右子树高度比左子树高度大1以上\n    } else if (getAvlTreeHeight(node.right) - getAvlTreeHeight(node.left) > 1) {\n        if (getAvlTreeHeight(node.right.right) >= getAvlTreeHeight(node.right.left)) {\n            // 如果右子树的右子树高度大于等于右子树的左子树高度\n            // 直接进行左单旋\n            node = roateLeft(node);\n        } else {\n            // 否则需要左-右双旋\n            node = roateLeftRight(node);\n        }\n    }\n    return node;\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br"),t("span",{staticClass:"line-number"},[e._v("14")]),t("br"),t("span",{staticClass:"line-number"},[e._v("15")]),t("br"),t("span",{staticClass:"line-number"},[e._v("16")]),t("br"),t("span",{staticClass:"line-number"},[e._v("17")]),t("br"),t("span",{staticClass:"line-number"},[e._v("18")]),t("br"),t("span",{staticClass:"line-number"},[e._v("19")]),t("br"),t("span",{staticClass:"line-number"},[e._v("20")]),t("br"),t("span",{staticClass:"line-number"},[e._v("21")]),t("br"),t("span",{staticClass:"line-number"},[e._v("22")]),t("br"),t("span",{staticClass:"line-number"},[e._v("23")]),t("br"),t("span",{staticClass:"line-number"},[e._v("24")]),t("br"),t("span",{staticClass:"line-number"},[e._v("25")]),t("br"),t("span",{staticClass:"line-number"},[e._v("26")]),t("br"),t("span",{staticClass:"line-number"},[e._v("27")]),t("br")])]),t("p",[e._v("每次插入节点，都需要做一次树的平衡处理：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var insertNode = function(node, newNode){\n    if (newNode.key < node.key){\n        if (node.left === null){\n            node.left = newNode;\n            // 插入节点后，做树的平衡处理\n            node.left = balance(node.left);\n        } else {\n            insertNode(node.left, newNode);\n        }\n    } else {\n        if (node.right === null){\n            node.right = newNode;\n            // 插入节点后，做树的平衡处理\n            node.right = balance(node.right);\n        } else {\n            insertNode(node.right, newNode);\n        }\n    }\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br"),t("span",{staticClass:"line-number"},[e._v("14")]),t("br"),t("span",{staticClass:"line-number"},[e._v("15")]),t("br"),t("span",{staticClass:"line-number"},[e._v("16")]),t("br"),t("span",{staticClass:"line-number"},[e._v("17")]),t("br"),t("span",{staticClass:"line-number"},[e._v("18")]),t("br"),t("span",{staticClass:"line-number"},[e._v("19")]),t("br")])]),t("hr"),e._v(" "),t("p",[e._v("u1s1，当树开始旋转，脑袋也有点晕眩了╮(╯▽╰)╭")]),e._v(" "),t("p",[e._v("啃不下来，就先收藏慢慢啃吧~~")]),e._v(" "),t("p",[e._v("不慌，后续还会带来更多关于平衡二叉树的练习，以及前端少有接触的红黑树等等。。。")]),e._v(" "),t("p",[e._v("OK，以上就是本篇分享~ 撰文不易，点赞鼓励👍👍👍")]),e._v(" "),t("blockquote",[t("p",[e._v("我是掘金安东尼，公众号同名，日拱一卒、日掘一金，再会~")])]),e._v(" "),t("p",[e._v("参考：")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://zh.wikipedia.org/wiki/AVL%E6%A0%91",target:"_blank",rel:"noopener noreferrer"}},[e._v("wikipedia"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://adrianmejia.com/self-balanced-binary-search-trees-with-avl-tree-data-structure-for-beginners/#Tree-rotations",target:"_blank",rel:"noopener noreferrer"}},[e._v("Self-balanced Binary Search Trees with AVL in JavaScript"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6844903474337939470",target:"_blank",rel:"noopener noreferrer"}},[e._v("二叉排序树、红黑树、AVL 树最简单的理解"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000008619134",target:"_blank",rel:"noopener noreferrer"}},[e._v("学习JavaScript数据结构与算法 — AVL树"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);n.default=s.exports}}]);