(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{555:function(s,a,t){"use strict";t.r(a);var n=t(2),e=Object(n.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"滑动窗口算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口算法"}},[s._v("#")]),s._v(" 滑动窗口算法")]),s._v(" "),t("p",[t("strong",[s._v("滑动窗口算法可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度。")])]),s._v(" "),t("p",[s._v("比如给定如下数组：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("[ 5, 7, 1, 4, 3, 6, 2, 9, 2 ]\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("求出 5 个连续元素的最大和是多少？")]),s._v(" "),t("p",[t("code",[s._v("[5, 7, 1, 4, 3]")]),s._v(" 是第一组 5 个连续元素，求和是 "),t("code",[s._v("20")]),s._v("，"),t("code",[s._v("[7, 1, 4, 3, 6]")]),s._v(" 是第二组 5 个连续元素，求和是 "),t("code",[s._v("21")]),s._v("......这样一直进行下去，最终对比发现 5 个连续元素的最大和是 "),t("code",[s._v("24")]),s._v("，由 "),t("code",[s._v("[4, 3, 6, 2, 9]")]),s._v(" 组成；")]),s._v(" "),t("p",[s._v("简单粗暴的双层 for 循环算法实现：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("const getMaxSumOfFiveContiguousElements = (arr) => {\n  let maxSum = -Infinity;\n  let currSum;\n\n  for (let i = 0; i <= arr.length - 5; i++) {\n    currSum = 0;\n\n    for (let j = i; j < i + 5; j++) {\n      currSum += arr[j];\n    }\n\n    maxSum = Math.max(maxSum, currSum);\n  }\n\n  return maxSum;\n};\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br")])]),t("p",[s._v("时间复杂度是 "),t("code",[s._v("O(n*k)")]),s._v("，遍历情况如图示：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70e2bea61449447c9e1b56cfa59a6726~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),s._v(" "),t("p",[t("strong",[s._v("而通过滑动窗口算法，我们能将时间复杂度降低为 "),t("code",[s._v("O(n)")]),s._v("；")])]),s._v(" "),t("p",[s._v("我们将 5 个连续的元素放入一个窗口内，每做一次求和计算后，将窗口内的第一个数字减掉，然后再加上窗口外的后第一个数字，形成新的窗口，窗口长度不变，这样一直操作下去，直到窗口遍历完全部元素，结束遍历；")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05893218fb06464aa6d134bc17a28e26~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),s._v(" "),t("p",[s._v("算法如下：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("const getLargestSumOfFiveConsecutiveElements = (arr) => {\n  let currSum = getSum(arr, 0, 4);\n  let largestSum = currSum;\n\n  for (let i = 1; i <= arr.length - 5; i++) {\n    currSum -= arr[i - 1]; // subtract element to the left of curr window\n    currSum += arr[i + 4]; // add last element in curr window\n    largestSum = Math.max(largestSum, currSum);\n  }\n\n  return largestSum;\n};\n\nconst getSum = (arr, start, end) => {\n  let sum = 0;\n\n  for (let i = start; i <= end; i++) {\n    sum += arr[i];\n  }\n\n  return sum;\n};\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br")])]),t("p",[s._v("遍历图示：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e3a1438f30440c68a76fd81262d439b~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),s._v(" "),t("p",[s._v("通过 "),t("code",[s._v("+1")]),s._v(" "),t("code",[s._v("-1")]),s._v(" 的方式实现遍历，将双循环变成单循环，降低时间复杂度，这正是滑动窗口的技术要点；")]),s._v(" "),t("p",[s._v("当然，滑动窗口还有很多变形，比如长度不固定、滑动距离不是 1 ......")]),s._v(" "),t("p",[t("strong",[s._v("以上温故了滑动窗口的算法部分，接下来温故所学的 TCP 滑动窗口原理：")])]),s._v(" "),t("h2",{attrs:{id:"tcp-滑动窗口原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-滑动窗口原理"}},[s._v("#")]),s._v(" TCP 滑动窗口原理")]),s._v(" "),t("p",[s._v("起初，为了保证发送方与接收方之间，每个包都能被收到。并且是按次序的，发送过程是：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ea06862c7ee4815975fe24ff3721860~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),s._v(" "),t("p",[s._v("但是，这样又太慢了，于是升级为多个并行发送，加大吞吐量：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ada91d8315884e22948cbff2db342d63~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),s._v(" "),t("p",[s._v("后来，为了实现“无序”发送，即做到：发送方拿到确认包 1 的时候，就发送包 3，而不是非要等拿到确认包 2 才能发包 3；")]),s._v(" "),t("p",[s._v("于是乎，滑动窗口粉墨登场；")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99e64f50dc6e4be4983d6134d38334e0~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),s._v(" "),t("p",[s._v("窗口分为："),t("code",[s._v("已发送（未Ack）")]),s._v("和"),t("code",[s._v("待发送（未Ack）")]),s._v("两个部分，当已发送被 Ack 确认后，则发生窗口移动，将"),t("code",[s._v("未发送")]),s._v("的包划到"),t("code",[s._v("待发送")]),s._v("中去，这样一直移动下去，直至所有包发送完毕；针对丢包情况，滑动窗口有"),t("code",[s._v("超时重传")]),s._v("机制；")]),s._v(" "),t("p",[s._v("滑动窗口的最大优势在于：接收端可以根据自己的状况通告窗口大小，从而控制发送端的接收，进行"),t("code",[s._v("流量控制")]),s._v("。")]),s._v(" "),t("hr"),s._v(" "),t("p",[s._v("本篇温故算是小引，后续会带来更多关于滑动窗口的变形算法或应用~")]),s._v(" "),t("p",[s._v("我是掘金安东尼，公众号同名，输出暴露输入，技术洞见生活，下次再会~~")])])}),[],!1,null,null,null);a.default=e.exports}}]);