(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{606:function(s,n,a){"use strict";a.r(n);var e=a(2),t=Object(e.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"实战背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实战背景"}},[s._v("#")]),s._v(" 实战背景")]),s._v(" "),a("p",[s._v("前面已经写了 7 篇关于 JS 函数式编程、2 篇关于函数组合、2 篇关于 Haskell 入门，想看的话，可以在我的 "),a("a",{attrs:{href:"https://juejin.cn/column/6960836897669120036",target:"_blank",rel:"noopener noreferrer"}},[s._v("JS 专栏"),a("OutboundLink")],1),s._v(" 中找到它们；")]),s._v(" "),a("p",[s._v("不过，这一切只是刚刚起步......")]),s._v(" "),a("p",[s._v("本瓜为什么青睐函数式编程，甚至把它视如前端项目的救命稻草？")]),s._v(" "),a("p",[s._v("原因是：本瓜所在一个大型 Web 项目下（自认为），每个版本几乎由 6 个前端协同开发，算上前后离职的，该项目前后经手 10+ 个前端之手；由于“历史原因”，个人评估现在的项目大致存在这些问题：")]),s._v(" "),a("ol",[a("li",[s._v("逻辑封装欠缺：很难从代码层面看清业务设计是怎样的；")]),s._v(" "),a("li",[s._v("公用方法封装欠缺：同一个功能经不同开发之手，有多种不同种实现方式；")]),s._v(" "),a("li",[s._v("debugger 困难：排查问题需要梳理很长的一段流程，其间很多小坑、小判断；")]),s._v(" "),a("li",[s._v("重构困难：代码之间有着千丝万缕的干涉，状态管理较乱，隐式输入、输出很多；")]),s._v(" "),a("li",[s._v("响应需求慢：有时候需求变更的快，代码又没办法快速响应，只得临时堆叠逻辑，增加藏匿 bug 风险，导致后续难跟进的恶性循环；")]),s._v(" "),a("li",[s._v("。。。。。。")])]),s._v(" "),a("p",[s._v("总结起来就是："),a("strong",[s._v("高质量代码三要素：可读、可维护、易变更")]),s._v(" 雨我无瓜！")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://imagelol.com/image/It91fE",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://s3.jpg.cm/2021/09/06/It91fE.md.png",alt:"It91fE.md.png"}}),a("OutboundLink")],1)]),s._v(" "),a("p",[s._v("于是乎，得寻找解决方法呀！上 TypeScript 可以吗？应该可以，强类型对于大型项目还是挺重要的！！")]),s._v(" "),a("p",[s._v("但是 Vue2 + TS 体验差（没看到很好的实践项目，有的话，推给我😳），那先把 Vue2 升到 Vue3，然后再上 TS 行不？")]),s._v(" "),a("p",[s._v("别闹了，项目较大，也不是说升就能升的，涉及的人力、时间，学习成本、重构风险等，水太深，不好把握；")]),s._v(" "),a("p",[s._v("甚至，再进一步，强类型也并不能解决上述问题！")]),s._v(" "),a("p",[s._v("这里需要一个"),a("strong",[s._v("更高层次的设计")]),s._v("来进行降维打击！")]),s._v(" "),a("p",[s._v("此时，"),a("strong",[s._v("函数式编程")]),s._v("一招“如来神掌”，从天而降，并莞尔一笑：“这个啊，我熟~”")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://imagelol.com/image/It9rd2",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://s3.jpg.cm/2021/09/06/It9rd2.md.gif",alt:"It9rd2.md.gif"}}),a("OutboundLink")],1)]),s._v(" "),a("p",[s._v("下面，我们来看看它带来了哪些天赋！！")]),s._v(" "),a("h2",{attrs:{id:"天赋点1-纯函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#天赋点1-纯函数"}},[s._v("#")]),s._v(" 天赋点1：纯函数")]),s._v(" "),a("p",[s._v("什么是纯函数？紧扣定义：")]),s._v(" "),a("blockquote",[a("ol",[a("li",[a("p",[s._v("给定相同的输入，总是返回相同的输出（或称为：引用透明性）；")])]),s._v(" "),a("li",[a("p",[s._v("没有副作用；")])])])]),s._v(" "),a("ul",[a("li",[s._v("“给定相同的输入，总是返回相同的输出” 什么意思？")])]),s._v(" "),a("p",[s._v("比如在数学计算中，"),a("code",[s._v("f(x)=x/2")]),s._v("，"),a("code",[s._v("f(10)")]),s._v(" 无论计算 100 次还是 1000 次，其结果都是 5；")]),s._v(" "),a("p",[s._v("但在程序设计中，函数不具备这种稳定的特性，因为函数的执行不仅依赖于输入值，还依赖引用的全局变量、输入文件、类的成员变量等诸多因素的影响；")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("int counter = 0\nint count(){\n    return ++counter;\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("如果函数的返回值只依赖于其输入值，我们把这种特性称作引用透明性（referential transparency）。")]),s._v(" "),a("ul",[a("li",[s._v("“没有副作用” 什么意思？")])]),s._v(" "),a("p",[s._v("指调用函数时，只有【函数的返回值】会对函数外的变量进行修改；")]),s._v(" "),a("p",[s._v("在函数式编程中，副作用大多被避免，这使得程序的效果更容易理解，也更容易测试。")]),s._v(" "),a("p",[s._v("但在 JS 中要想保证函数无副作用这项特性，只能依靠编程人员的习惯：")]),s._v(" "),a("p",[s._v("a. 函数入口使用参数运算，而不修改它；\nb. 函数内不修改函数外的变量，如全局变量；\nc. 最总运算结果只通过函数返回给外部；")]),s._v(" "),a("p",[s._v("将副作用与程序逻辑的其余部分分开，您的软件将更容易扩展、重构、调试、测试和维护。")]),s._v(" "),a("p",[s._v("这也是大多数前端框架鼓励用户在单独的、解耦的模块中管理状态和组件渲染的原因。")]),s._v(" "),a("p",[a("strong",[s._v("引用透明性保障了函数的输入，即解决了隐式的输入；没有副作用保障了函数的输出，即解决了隐式的输出；")])]),s._v(" "),a("h2",{attrs:{id:"天赋点2-不变性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#天赋点2-不变性"}},[s._v("#")]),s._v(" 天赋点2：不变性")]),s._v(" "),a("p",[s._v("不变性是函数式编程的核心概念，没有它，程序中的数据流是有损的；")]),s._v(" "),a("p",[s._v("怎么理解？即：在函数式编程中，依靠的是"),a("strong",[s._v("不可变")]),s._v("的数据结构和对从现有数据中进行"),a("strong",[s._v("纯计算")]),s._v("再获得到新的数据；")]),s._v(" "),a("p",[s._v("举个栗子🌰")]),s._v(" "),a("ul",[a("li",[s._v("在非函数式编程中：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const x = {\n  val: 2\n};\nconst x1 = () => x.val += 1;\nconst x2 = () => x.val *= 2;\nx1();\nx2();\nconsole.log(x.val); // 6\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("我们修改了变量 x，如果更改调用顺序，会导致结果不一样；")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const x = {\n  val: 2\n};\nconst x1 = () => x.val += 1;\nconst x2 = () => x.val *= 2;\nx2();\nx1();\nconsole.log(x.val); // 5\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("为了知道函数的执行结果，"),a("strong",[s._v("必须追踪变量完整的历史记录")]),s._v("；")]),s._v(" "),a("ul",[a("li",[s._v("在函数式编程中：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const x = {\n  val: 2\n};\n\nconst x1 = x => Object.assign({}, x, { val: x.val + 1});\n\nconst x2 = x => Object.assign({}, x, { val: x.val * 2});\n\nconsole.log(x2(x1(y)).val); // 6\nconsole.log(x1(x2(x)).val); // 5\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("我们使用"),a("code",[s._v("Object.assign()")]),s._v("来产生一个新对象，而不是直接修改 x，这非常重要！")]),s._v(" "),a("p",[s._v("有人会问，"),a("code",[s._v("x2(x1(y)).val")]),s._v(" 变成 "),a("code",[s._v("x1(x2(x)).val")]),s._v(" 不也是修改顺序了嘛？")]),s._v(" "),a("p",[s._v("没错，函数组合的顺序仍然很重要，但你不用担心外部变量 x 发生了什么样的变化！"),a("strong",[s._v("当你想在任何其它地方调用 x 的时候，你知道：x.val 一定就是 2 !")])]),s._v(" "),a("p",[s._v("这一点太有感触了！我们总是在不断地覆盖之前的值、不断的修改已经变化过的值，导致不敢轻易用这个变量，再新建一个变量，再叠加逻辑，可能更“稳妥”（实际会更乱）~")]),s._v(" "),a("blockquote",[a("p",[s._v("消除函数调中对于各种状态的时间依赖性，可以消除很很大一部分潜在的错误。")])]),s._v(" "),a("p",[s._v("然后，const 并不能保证变量不可变！")]),s._v(" "),a("p",[s._v("使用 const 定义一个对象后，仍然可以修改对象的属性，这是 JavaScript 的奇妙之处 (ˉ▽ˉ；)...")]),s._v(" "),a("p",[s._v("不过，有一个"),a("code",[s._v("freeze")]),s._v("方法可以保证对象的一级属性也不可变：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const a = Object.freeze({\n  foo: 'Hello',\n  bar: 'world',\n  baz: '!'\n});\n\na.foo = 'Goodbye';\nconsole.log(a)//{foo: 'Hello', bar: 'world', baz: '!'}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("对，只保证一级属性，再下一级的属性，就不能保证了")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const a = Object.freeze({\n  foo: { greeting: 'Hello' },\n  bar: 'world',\n  baz: '!'\n});\n\na.foo.greeting = 'Goodbye';\n\nconsole.log(`${ a.foo.greeting }, ${ a.bar }${a.baz}`);// Goodbye, world!\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("在许多函数式编程语言中，有一种特殊的不可变的数据结构（trie 树、字典树）；")]),s._v(" "),a("p",[s._v("JS 中，我们可以借助 "),a("a",{attrs:{href:"https://immutable-js.com/",target:"_blank",rel:"noopener noreferrer"}},[s._v("Immutable.js"),a("OutboundLink")],1),s._v(" 来让我们的对象深度不可变！不会更改任何属性！")]),s._v(" "),a("h2",{attrs:{id:"天赋点3-函数组合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#天赋点3-函数组合"}},[s._v("#")]),s._v(" 天赋点3：函数组合")]),s._v(" "),a("p",[s._v("之前写过两篇关于函数组合的实战：")]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://juejin.cn/post/6989020415444123662",target:"_blank",rel:"noopener noreferrer"}},[s._v("《感谢 compose 函数，让我的代码屎山💩逐渐美丽了起来~》"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.cn/post/6996811608756322334",target:"_blank",rel:"noopener noreferrer"}},[s._v("《从【if...else...】到【责任链】再到【composeAOP】，顺带把【传参】解决了~》"),a("OutboundLink")],1)])]),s._v(" "),a("p",[s._v("函数组合就是说：将两个或多个函数组合起来执行一系列计算过程；比如在 JavaScript 中会这样写："),a("code",[s._v("a(b(c(x)))")]),s._v("，把一个函数的输出再注入到下一个函数的输入中，连续执行；")]),s._v(" "),a("p",[s._v("理解函数组合式理解函数式编程的关键！")]),s._v(" "),a("h2",{attrs:{id:"天赋点4-高阶函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#天赋点4-高阶函数"}},[s._v("#")]),s._v(" 天赋点4：高阶函数")]),s._v(" "),a("p",[s._v("函数式编程倾向于重用一组通用的函数式实用程序来处理数据；")]),s._v(" "),a("p",[s._v("而面向对象编程倾向于将方法和数据并置在对象中；")]),s._v(" "),a("p",[s._v("JavaScript 具有一流的函数，它允许我们将函数视为数据，"),a("strong",[s._v("将函数作为一个参数传递到其它函数，或者从函数中返回另一个函数")]),s._v("，这就是高阶函数；")]),s._v(" "),a("p",[s._v("高阶函数通常适用于：")]),s._v(" "),a("p",[s._v("a. 使用回调函数、promise、monads 等进行抽象封装、隔离环境、或控制异步流；\nb. 创建可以接受多种数据类型的程序；\nc. 创建柯里化函数或函数组合，以实现重用；")]),s._v(" "),a("p",[s._v("比如我们常用的 "),a("code",[s._v("map()")]),s._v(" 方法，可用于任何数据类型：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const double = n => n * 2;\nconst doubleMap = numbers => numbers.map(double);\nconsole.log(doubleMap([2, 3, 4])); // [ 4, 6, 8 ]\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("我们将 "),a("code",[s._v("double")]),s._v(" 函数传入了 "),a("code",[s._v("map()")]),s._v(" 中，然后进行映射得到新的结果数组；")]),s._v(" "),a("p",[s._v("挖坑：本瓜后面会专门针对高阶映射（map、filter、reduce）输出；")]),s._v(" "),a("p",[s._v("我们还能进一步拓展 "),a("code",[s._v("double")]),s._v(" 函数：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const double = n => n.points * 2;\n\nconst doubleMap = numbers => numbers.map(double);\n\nconsole.log(doubleMap([\n  { name: 'ball', points: 2 },\n  { name: 'coin', points: 3 },\n  { name: 'candy', points: 4}\n])); // [ 4, 6, 8 ]\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("h2",{attrs:{id:"阶段总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阶段总结"}},[s._v("#")]),s._v(" 阶段总结")]),s._v(" "),a("p",[s._v("命令式代码经常使用语句包括 for、if、switch、throw 等来执行一些动作；")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const doubleMap = numbers => {\n  const doubled = [];\n  for (let i = 0; i < numbers.length; i++) {\n    doubled.push(numbers[i] * 2);\n  }\n  return doubled;\n};\n\nconsole.log(doubleMap([2, 3, 4])); // [4, 6, 8]\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("而函数式编程是一种声明式范式，抽象了流程，确数了据流；")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const doubleMap = numbers => numbers.map(n => n * 2);\n\nconsole.log(doubleMap([2, 3, 4])); // [4, 6, 8]\n\ndoubleMap([2, 3, 4]) \n\nMath.max(4, 3, 2)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("实际上，基本上每个大型应用程序代码库都大量使用了函数式编程思想。")]),s._v(" "),a("p",[s._v("函数式编程是一种编程范式，这意味着它是一种基于一些基本的定义原则来思考软件构造的方式：")]),s._v(" "),a("p",[s._v("这些原则就是以上所讲")]),s._v(" "),a("ol",[a("li",[s._v("纯函数；")]),s._v(" "),a("li",[s._v("不变性；")]),s._v(" "),a("li",[s._v("函数组合；")]),s._v(" "),a("li",[s._v("高阶函数；")])]),s._v(" "),a("p",[s._v("函数式代码往往更简洁、更可预测且更易于测试！！")])])}),[],!1,null,null,null);n.default=t.exports}}]);