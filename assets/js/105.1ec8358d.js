(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{598:function(s,a,n){"use strict";n.r(a);var e=n(2),t=Object(e.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h2",{attrs:{id:"函数本质"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数本质"}},[s._v("#")]),s._v(" 函数本质")]),s._v(" "),n("blockquote",[n("p",[n("strong",[s._v("Haskell 里变量的值在绑定后不会改变，所有变量一定意义上可以理解为定值。")])]),s._v(" "),n("p",[s._v("无论如何，定义过的值是没法再改变的。")]),s._v(" "),n("p",[s._v("Haskell 值与函数是统一的，函数只是需要其他参数输入的值。如果定义的是函数，那么这个函数的行为在运行过程中也是不会改变的，"),n("strong",[s._v("对于某一个特定的输入返回的结果总是确定的，这样的函数为纯函数。")])]),s._v(" "),n("p",[s._v("有人觉得不改内存状态的想法听上去很荒诞，甚至觉得这样是没有办法做计算的。其实，这两种想法都是错误的。不改变内存状态自有道理，而其它编程语言可以完成的工作，Haskell 一样可以完成。")])]),s._v(" "),n("p",[s._v("再三强调，在 Haskell 中，"),n("strong",[s._v("函数与值没有本质的区别")]),s._v("，它可以是单一的定值，也可以是任意两个函数间的映射；实际上，在 Haskell 世界里，所有的运算符号都可以被看做是函数，如加号 + 是一个需要两个参数的函数。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Prelude> (+)5 7\n12\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("h2",{attrs:{id:"函数定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数定义"}},[s._v("#")]),s._v(" 函数定义")]),s._v(" "),n("p",[s._v("直接来干的~")]),s._v(" "),n("p",[s._v("实现：f(x) = 4x+ 1")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Prelude> f1(x)=4*x + 1\nPrelude> f1 4\n17\nPrelude> :t f1\nf1 :: Num a => a -> a\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("再比如实现：f(x,y) = 4x+ 5y+ 1，")]),s._v(" "),n("p",[s._v("我们可以设想到这个函数的类型是：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("f2 :: Num a => (a, a) -> a\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])]),n("p",[s._v("验证一下：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Prelude> f2(x,y)=4*x+5*y+1\nPrelude> f2(4,3)\n32\nPrelude> :t f2\nf2 :: Num a => (a, a) -> a\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("确实如此；")]),s._v(" "),n("p",[s._v("Haskell 中定义的函数的大致格式是这样的：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// 定义方式 1\n\n函数名 (参数1,参数2,...) = 函数体\n\n// 定义方式 2\n\n函数名 参数1 参数2.. =函数体\n\n// 类型\n\n函数名 :: 参数1的类型->参数2的类型->...->结果类型\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])]),n("p",[s._v("说这么多，不如在编译器中感受感受：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Prelude> f3 x y z=3*x+2*y-z\nPrelude> f3 1 2 3\n4\nPrelude> :t f3\nf3 :: Num a => a -> a -> a -> a\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[n("strong",[s._v("我们惊人的发现，从定义方式 1 到 定义方式 2 的过程，就是柯里化的过程！")])]),s._v(" "),n("h2",{attrs:{id:"λ表达式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#λ表达式"}},[s._v("#")]),s._v(" λ表达式")]),s._v(" "),n("p",[s._v("Haskell 还有另外一种书写函数的格式，即 λ 表达式；")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// 定义方式 3\n\n函数名= (\\参数1 -> \\参数2 -> ... ->函数体)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("示例：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Prelude> f4= (\\x -> \\y -> x*y)\nPrelude> f4 2 3\n6\n\nPrelude> f5 =(\\x -> \\y->4*x+5*y+1)\nPrelude> f5 2 3\n24\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("p",[s._v("在使用一些高阶函数时，如果不想定义新函数，可以使用 λ 表达式来定义这个函数：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Prelude> map(\\x->2*x+7)[1..10]\n[9,11,13,15,17,19,21,23,25,27]\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[s._v("\\x -> 2*x+7 是一个没有名字的匿名函数，在 Haskell 中，通常用 λ 表达式来构造匿名函数；")]),s._v(" "),n("h2",{attrs:{id:"小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),n("p",[s._v("我们再来回归三种定义函数的方式：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// 方式 1：\n\nf2(x,y)=4*x+5*y+1\n\n// 方式 2：\n\nf3 x y z=3*x+2*y-z\n\n// 方式 3：\n\nf4= (\\x -> \\y -> x*y)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])])])}),[],!1,null,null,null);a.default=t.exports}}]);