(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{589:function(s,n,a){"use strict";a.r(n);var t=a(2),e=Object(t.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"小引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小引"}},[s._v("#")]),s._v(" 小引")]),s._v(" "),a("p",[s._v("JavaScript 技能持有者一定有问过这个问题：")]),s._v(" "),a("blockquote",[a("p",[s._v("JavaScript 是面向对象语言吗？")])]),s._v(" "),a("p",[s._v("你期望得到的答案应该为：“是” 或 “不是”。")]),s._v(" "),a("p",[s._v("但是可惜，你得不到这样简单的答案！")]),s._v(" "),a("p",[s._v("你大概了解一通之后，你会被告知：")]),s._v(" "),a("blockquote",[a("p",[s._v("JavaScript 不是纯粹的面向对象语言！")])]),s._v(" "),a("p",[s._v("wtf！为什么是不纯粹？能不能纯粹一点？！我们喜欢纯粹，不喜欢混沌！")]),s._v(" "),a("p",[s._v("......")]),s._v(" "),a("p",[s._v("实际上，死扣定义真的没太必要。定义背后的故事才是最重要的！")]),s._v(" "),a("p",[s._v("看完本篇，你就会明白这种“混沌”是什么、来自何处，以及去往何方！！")]),s._v(" "),a("p",[s._v("撰文不易，多多鼓励。点赞再看，养成习惯。👍👍👍")]),s._v(" "),a("h2",{attrs:{id:"类-设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类-设计模式"}},[s._v("#")]),s._v(" “类”设计模式")]),s._v(" "),a("p",[s._v("妇孺皆知，面向对象三大特性：【封装】、【继承】、【多态】。")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("所谓封装，即把客观事物封装成抽象的类。")])]),s._v(" "),a("li",[a("p",[s._v("所谓继承，即子类继承父类的能力。")])]),s._v(" "),a("li",[a("p",[s._v("所谓多态，即子类可以用更特殊的行为重写所继承父类的通用行为。")])])]),s._v(" "),a("p",[s._v("其中，“类”的概念最最关键！"),a("strong",[s._v("【类】描述了一种代码的组织结构形式，它是软件中对真实世界中问题领域的建模方法。")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("举个例子：\n\n就好比我们现实中修房子，你要修一个“写字楼”、或者一个“居民楼”、或者一个“商场”，你就得分别找到修“写字楼”、“居民楼”、“商场”的【设计蓝图】。\n\n但是设计蓝图只是一个建筑计划，并不是真正的建筑。要想在真实世界实现这个建筑，就得由建筑工人将设计蓝图的各类特性（比如长宽高、功能）【复制】到现实世界来。\n\n这里的【设计蓝图】就是【类】，【复制】的过程就是【实例化】，【实例】就是【对象】。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("类的内部通常有一个同名的构造方法，我们设想下，它的伪代码就可能是这样的：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('class Mall { // “商场”类\n\n    Mall( num ){ // 同名构造方法\n        garage = num // 地下车库数量\n    }\n\n    shop( goods ) { // 买东西\n       output( "We can buy: ", goods )\n    }\n\n}\n\nvanke = new Mall(1) // vanke 有 1 个地下车库 // 构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例。\n\nvanke.shop("KFC") // "We can buy: KFC"\n\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("p",[s._v("java 是典型的面向对象语言。基于“类”，我们再通过以下一段 java 代码来看看对"),a("strong",[s._v("继承")]),s._v("和"),a("strong",[s._v("多态")]),s._v("的理解。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('public abstract class Animal{ // 抽象类\n     abstract void sound();\n}\npublic class Chicken extends Animal{ // 继承\n    public void sound(){\n      sound("咯咯咯");\n    }\n}\npublic class Duck extends Animal{\n    public void sound(){\n      sound("嘎嘎嘎");\n    }\n}\n\npublic static void main(String args[]){\n  Aninal chicken = new Chicken();\n  Animal duck = new Duck();\n  chicken.sound(); //咯咯咯\n  duck.sound();  //嘎嘎嘎\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br")])]),a("p",[s._v("鸡和鸭都属于动物分类，都可以发出叫声（继承），但是它们却可以发出不同的叫声（多态），很容易理解。")]),s._v(" "),a("p",[s._v("继承可以使子类获得父类的全部功能；\n多态可以使程序有良好的扩展；")]),s._v(" "),a("p",[s._v("回想下：在 JS 中，我们可能会怎样写：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('var Duck = function () {};\nvar Chicken = function () {};\nvar makeSound = function ( animal ) {\n    if( animal instanceof Duck){\n        console.log("嘎嘎嘎");    \n    }else if( animal instanceof Chicken){\n        console.log("咯咯咯");    \n    }\n};\nmakeSound(new Duck());\nmakeSound(new Chicken());\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("这里既没用到继承，也没用到多态。这样【写判断】是代码“不清爽”的罪魁祸首！")]),s._v(" "),a("ul",[a("li",[s._v("此处留一个疑问，如果不用判断，还可以怎么写？")])]),s._v(" "),a("p",[s._v("在 vue2 中，我们可能会这么写：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('export default {\n  data() {\n      return {\n\n      },\n      mounted(){\n          this.Chicken()\n          this.Duck()\n      },\n      methods:{\n          funtion AnimalSound(sound){\n              console.log("叫声:" + sound)\n          },\n          funtion Chicken(){\n              this.AnimalSound("咯咯咯")\n          },\n          funtion Duck(){\n              this.AnimalSound("嘎嘎嘎")\n          }\n      }\n  }\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br")])]),a("p",[s._v("像这种函数嵌套调用是很常见的。没有看到继承，也没有看到多态，甚至都没有看到最根本的“类”？！")]),s._v(" "),a("p",[s._v("（实际上，每个函数都是一个 Function 对象。按照最开始定义所述，"),a("strong",[s._v("对象是类的实例")]),s._v("，所以也是能在函数中看到“类”的！）")]),s._v(" "),a("p",[s._v("在 JavaScript 中，"),a("strong",[s._v("函数成了第一等公民！")]),s._v(" 函数似乎什么都能做！它可以返回一个对象，可以赋值给一个变量，可以作为数组项，可以作为对象的一个属性......")]),s._v(" "),a("p",[s._v("但这明显不是“类的设计模式”吧！")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de199220d8ec4bf2980d53f6a7a83797~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),s._v(" "),a("p",[a("strong",[s._v("“类的设计模式”")]),s._v(" 意味着对【设计蓝图】的【复制】，在 JS 各种函数调用的场景下基本看不到它的痕迹。")]),s._v(" "),a("h2",{attrs:{id:"原型-设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型-设计模式"}},[s._v("#")]),s._v(" “原型”设计模式")]),s._v(" "),a("p",[s._v("其实，众所周知，JS 也是能做到【继承】和【多态】的！只不过它不是通过类"),a("strong",[s._v("复制")]),s._v("的方式，而是通过原型链"),a("strong",[s._v("委托")]),s._v("的方式！")]),s._v(" "),a("p",[s._v("一图看懂原型链？")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1675f6c23cca4593b1418fdbd18b459f~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),s._v(" "),a("p",[s._v("看不懂？没关系，记住这两句话再来看:")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("一个对象的显示原型的构造函数指向本身")]),s._v("（很熟悉有没有？在本文哪里见过？）")]),s._v(" "),a("li",[a("strong",[s._v("一个对象的隐式原型指向构造这个对象的函数的显示原型。")])])]),s._v(" "),a("p",[s._v("原来，JS 不是通过在类里面写同名构造函数的方式来进一步实现的实例化，它的构造函数在原型上！这种更加奇特的代码服用机制有异于经典类的代码复用体系。")]),s._v(" "),a("p",[s._v("这里再附一个经典问题？JS new 操作会发生什么？")]),s._v(" "),a("p",[s._v("会是像类那样进行复制吗？")]),s._v(" "),a("p",[s._v("答案是否定的！")]),s._v(" "),a("p",[s._v("JS 访问一个对象的属性或方法的时候，先在对象本身中查找，如果找不到，则到原型中查找，如果还是找不到，则进一步在原型的原型中查找，一直到原型链的最末端。复制不是它所做的，这种查找的方式才是！对象之间的关系更像是一种委托关系，就像找东西，你在我这找不到？就到有委托关系的其它人那里找找看，再找不到，就到委托委托关系的人那里找......直至尽头，最后还找不到，指向 null。")]),s._v(" "),a("blockquote",[a("p",[s._v("所以：JavaScript 和面向对象的语言不同，它并没有类来作为对象的抽象模式或者设计蓝图。JavaScript 中只有对象，对象直接定义自己的行为。对象之间的关系是委托关系，这是一种极其强大的设计模式。"),a("strong",[s._v("在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的！")])])]),s._v(" "),a("p",[s._v("不过你也可以通过这种委托的关系来模拟经典的面向对象体系：类、继承、多态。但“类”设计模式只是一种可选的设计模式，你可以模拟，也可以不模拟！")]),s._v(" "),a("p",[s._v("现实是 ES6 class 给我们模拟了：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('class Widget { \n    constructor(width,height) { \n        this.width = width || 50; \n        this.height = height || 50; \n        this.$elem = null; \n    } \n    render($where){ \n        if (this.$elem) { \n            this.$elem.css( { \n                width: this.width + "px", \n                height: this.height + "px" \n            }).appendTo( $where ); \n        } \n    } \n} \nclass Button extends Widget { \n    constructor(width,height,label) { \n        super( width, height ); \n        this.label = label || "Default"; \n        this.$elem = $( "<button>" ).text( this.label ); \n    } \n    render($where) { \n        super.render( $where ); \n        this.$elem.click( this.onClick.bind( this ) ); \n    } \n    onClick(evt) { \n        console.log( "Button \'" + this.label + "\' clicked!" ); \n    } \n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br")])]),a("p",[s._v("看起来，非常不错，很清晰！")]),s._v(" "),a("p",[s._v("没有 .prototype 显示原型复杂的写法，也无需设置 .proto 隐式原型。还似乎用 extends 、super 实现了继承和多态。")]),s._v(" "),a("p",[s._v("然而，这只是语法糖的陷阱！JS 没有类，没有复制，它的机制是“委托”。")]),s._v(" "),a("p",[s._v("class 并不会像传统面向类的语言一样在申明时作静态复制的行为，如果你有意或者无意修改了父类，那子类也会收到影响。")]),s._v(" "),a("p",[s._v("举例：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('class C { \n constructor() { \n    this.num = Math.random(); \n } \n rand() { \n    console.log( "Random: " + this.num ); \n } \n} \nvar c1 = new C(); \nc1.rand(); // "Random: 0.4324299..."\nC.prototype.rand = function() { \n    console.log( "Random: " + Math.round( this.num * 1000 )); \n}; \nvar c2 = new C(); \nc2.rand(); // "Random: 867"\nc1.rand(); // "Random: 432" ——噢！\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("p",[s._v("ES6 class 混淆了“类设计模式”和“原型设计模式”。它最大的问题在于，它的语\n法有时会让你认为，定义了一个 class 后，它就变成了一个（未来会被实例化的）东西的\n静态定义。你会彻底忽略 Class 是一个对象，是一个具体的可以直接交互的东西。当然，它还有其它细节问题，比如属性覆盖方法、super 绑定的问题，有兴趣自行了解。")]),s._v(" "),a("blockquote",[a("p",[s._v("class 似乎想告诉你：“动态太难实现了，所以这可能不是个好主意。这里有一\n种看起来像静态的语法，所以编写静态代码吧。” —— 《你不知道的 JavaScript》")])]),s._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("“类设计模式”的构造函数挂在同名的类里面，类的继承意味着复制，多态意味着复制 + 自定义。")])]),s._v(" "),a("li",[a("p",[s._v("“原型设计模式”的构造函数挂在原型上，原型的查找是一种自下而上的委托关系。")])]),s._v(" "),a("li",[a("p",[s._v("“类设计模式”的类定义之后就不支持修改。")])]),s._v(" "),a("li",[a("p",[s._v("“原型设计模式”讲究的是一种动态性，任何对象的定义都可以修改，这和 JavaScript 作为脚本语言所需的动态十分契合！")])])]),s._v(" "),a("p",[s._v("你可以用“原型设计模式”来模拟“类设计模式”，但是这大概率是得不偿失的。")]),s._v(" "),a("p",[s._v("最后，如果再被问道：JavaScript 是面向对象语言吗？")]),s._v(" "),a("p",[s._v("如果这篇文章看懂了，就可以围绕：“类设计模式”和“原型设计模式”来吹了。")]),s._v(" "),a("p",[s._v("如果本文没有看懂，就把下面的标答背下来吧......")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01d2997140ed4eb9a7017b3f64343da3~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),s._v(" "),a("h2",{attrs:{id:"参考文献"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[s._v("#")]),s._v(" 参考文献")]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://justjavac.com/named-function-expressions-demystified.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("命名函数表达式探秘"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/71879386",target:"_blank",rel:"noopener noreferrer"}},[s._v("函数式和面向对象编程有什么区别？"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"http://www.mollypages.org/tutorials/js.mp",target:"_blank",rel:"noopener noreferrer"}},[s._v("tutorials/js.mp"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://www.ituring.com.cn/book/1488",target:"_blank",rel:"noopener noreferrer"}},[s._v("你不知道的JavaScript"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://wizardforcel.gitbooks.io/functional-light-js/content/ch5.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("JavaScript 轻量级函数式编程"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);n.default=e.exports}}]);