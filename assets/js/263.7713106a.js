(window.webpackJsonp=window.webpackJsonp||[]).push([[263],{763:function(n,s,a){"use strict";a.r(s);var e=a(2),t=Object(e.a)({},(function(){var n=this,s=n.$createElement,a=n._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("p",[n._v("本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究!")]),n._v(" "),a("h2",{attrs:{id:"专栏简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#专栏简介"}},[n._v("#")]),n._v(" 专栏简介")]),n._v(" "),a("blockquote",[a("p",[n._v("作为一名 5 年经验的 JavaScript 技能拥有者，笔者时常在想，它的核心是什么？后来我确信答案是：闭包和异步。而函数式编程能完美串联了这两大核心，从高阶函数到函数组合；从无副作用到延迟处理；从函数响应式到事件流，从命令式风格到代码重用。所以，本专栏将从函数式编程角度来再看 JavaScript 精要，欢迎关注！"),a("a",{attrs:{href:"https://juejin.cn/column/7140154838981017613",title:"https://juejin.cn/column/7140154838981017613",target:"_blank",rel:"noopener noreferrer"}},[n._v("传送门"),a("OutboundLink")],1)])]),n._v(" "),a("h2",{attrs:{id:"前情回顾"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前情回顾"}},[n._v("#")]),n._v(" 前情回顾")]),n._v(" "),a("p",[n._v("我们在前篇 "),a("a",{attrs:{href:"https://juejin.cn/post/7144851873411891207",target:"_blank",rel:"noopener noreferrer"}},[n._v("《✨从历史讲起，JavaScript 基因里写着函数式编程》"),a("OutboundLink")],1),n._v(" 讲到了 JavaScript 的函数式基因最早可追溯到 1930 年的 lambda 运算，这个时间比第一台计算机诞生的时间都还要早十几年。JavaScript 闭包的概念也来源于 lambda 运算中变量的被绑定关系。")]),n._v(" "),a("p",[a("strong",[n._v("因为在 lambda 演算的设定中，参数只能是一个，所以通过柯里化的天才想法来实现接收多个参数：")])]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("lambda x. ( lambda y. plus x y )\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br")])]),a("p",[n._v("说这个想法是“天才”一点不为过，把函数自身作为输入参数或输出返回值，至今受用，也就是【高阶函数】的定义。")]),n._v(" "),a("p",[n._v("将上述 lambda 演算柯里化写法转变到 JavaScript 中，就变成了：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function add(a) {\n    return function (b) {\n        return a + b\n    }\n}\n\nadd(1)(2)\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br")])]),a("p",[n._v("所以，剖析闭包从柯里化开始，"),a("strong",[n._v("柯里化是闭包的“孪生子”。")])]),n._v(" "),a("p",[n._v("读完本篇，"),a("strong",[n._v("你会发现 JavaScript 高阶函数中处处是闭包、处处是柯里化~")])]),n._v(" "),a("h2",{attrs:{id:"百变柯里化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#百变柯里化"}},[n._v("#")]),n._v(" 百变柯里化")]),n._v(" "),a("p",[n._v("最开始，本瓜理解 "),a("a",{attrs:{href:"https://juejin.cn/post/7101094150518341639",target:"_blank",rel:"noopener noreferrer"}},[n._v("柯里化 == 闭包 + 递归"),a("OutboundLink")],1),n._v("，得出的柯里化写法是这样的：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" let arr = []\n function addCurry() {\n     let arg = Array.prototype.slice.call(arguments); // 递归获取后续参数\n     arr = arr.concat(arg);\n      if (arg.length === 0) { // 如果参数为空，则判断递归结束\n          return arr.reduce((a,b)=>{return a+b}) // 求和\n      } else {\n          return addCurry;\n      }\n  }\n\naddCurry(1)(2)(3)()\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br")])]),a("p",[n._v("但这样的写法， "),a("code",[n._v("addCurry")]),n._v(" 函数会引用一个外部变量 "),a("code",[n._v("arr")]),n._v("，不符合纯函数的特性，于是就优化为：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function addCurry() {\n    let arr = [...arguments]\n    let fn = function () {\n        if(arguments.length === 0) {\n\t    return arr.reduce((a, b) => a + b)\n        } else {\n            arr.push(...arguments)\n            return fn\n        }\n    }\n    return fn\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br")])]),a("p",[n._v("上述写法，又总是要以 ‘( )’ 空括号结尾，于是再改进为隐式转换 "),a("code",[n._v(".toString")]),n._v(" 写法：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function addCurry() {\n    let arr = [...arguments]\n    // 利用闭包的特性收集所有参数值\n    var fn = function() {\n        arr.push(...arguments);\n        return fn;\n    };\n    // 利用 toString 隐式转换\n    fn.toString = function () {\n        return arr.reduce(function (a, b) {\n            return a + b;\n        });\n    }\n    return fn;\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br")])]),a("ul",[a("li",[n._v("注意一些旧版本的浏览器隐式转换会默认执行")])]),n._v(" "),a("p",[n._v("好了，到这一步，如果你把上述三种柯里化写法都会手写了，那面试中考柯里化的基础一关算是过了。")]),n._v(" "),a("p",[n._v("然而，不止于此，柯里化实际存在很多变体， "),a("strong",[n._v("只有深刻吃透它的思想，而非停留在一种写法上，才能算得上“高级”、“优雅”。")])]),n._v(" "),a("p",[a("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19c5a9e5931f4c62a2c52cd565682b61~tplv-k3u1fbpfcp-watermark.image?",alt:"5a06-kicwvzp7773475.gif"}})]),n._v(" "),a("p",[n._v("接下来，让我们看看它怎么变？！")]),n._v(" "),a("h3",{attrs:{id:"缓存传参"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存传参"}},[n._v("#")]),n._v(" 缓存传参")]),n._v(" "),a("p",[n._v("柯里化最基础的用法是缓存传参。")]),n._v(" "),a("p",[n._v("我们经常遇到这样的场景：")]),n._v(" "),a("p",[n._v("已知一个 "),a("code",[n._v("ajax")]),n._v(" 函数，它有 3 个参数 url、data、callback")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function ajax(url, data, callback) {\n  // ...\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br")])]),a("p",[n._v("不用柯里化是怎样减少传参的呢？通常是以下这样，写死参数位置的方式来减少传参：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function ajaxTest1(data, callback) {\n  ajax('http://www.test.com/test1', data, callback);\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br")])]),a("p",[n._v("而通过柯里化，则是这样：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function ajax(url, data, callback) {\n  // ...\n}\n\nlet ajaxTest2 = partial(ajax,'http://www.test.com/test2')\n\najaxTest2(data,callback)\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br")])]),a("p",[n._v("其中 "),a("code",[n._v("partial")]),n._v(" 函数是这样写的：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function partial(fn, ...presetArgs) { // presetArgs 是需要先被绑定下来的参数\n  return function partiallyApplied(...laterArgs) { //  ...laterArgs 是后续参数\n        let allArgs =presetArgs.concat(laterArgs) // 收集到一起\n        return fn.apply(this, allArgs) // 传给回调函数 fn\n  }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br")])]),a("p",[a("strong",[n._v("柯里化固定参数的好处在：复用了原本的 ajax 函数，并在原有基础上做了修改")]),n._v("，取其精华，弃其糟粕，封装原有函数之后，就能为我所用。")]),n._v(" "),a("p",[n._v("并且  "),a("code",[n._v("partial")]),n._v("  函数不止对 "),a("code",[n._v("ajax")]),n._v(" 函数有作用，对于其它想减少传参的函数同样适用。")]),n._v(" "),a("h3",{attrs:{id:"缓存判断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存判断"}},[n._v("#")]),n._v(" "),a("strong",[n._v("缓存判断")])]),n._v(" "),a("p",[n._v("我们可以设想一个通用场景，假设有一个  handleOption 函数，当符合条件 'A'，执行语句："),a("code",[n._v("console.log('A')")]),n._v("；不符合时，则执行语句："),a("code",[n._v("console.log('others')")])]),n._v(" "),a("p",[n._v("转为代码即：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const handleOption = (param) =>{\n     if(param === 'A'){\n         console.log('A')\n     }else{\n         console.log('others')\n     }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br")])]),a("p",[a("strong",[n._v("现在的问题是")]),n._v("：我们每次调用 "),a("code",[n._v("handleOption('A')")]),n._v("，都必须要走完 if...else... 的判断流程。比如：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const handleOption = (param) =>{\n     console.log('每次调用 handleOption 都要执行 if...else...')\n     if(param === 'A'){\n         console.log('A')\n     }else{\n         console.log('others')\n     }\n}\n\nhandleOption('A')\nhandleOption('A')\nhandleOption('A')\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br")])]),a("p",[n._v("控制台打印：")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9ab5828645d4a0b8b8985558dcd8869~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),n._v(" "),a("blockquote",[a("p",[n._v("有没有什么办法，多次调用 "),a("code",[n._v("handleOption('A')")]),n._v("，却只走一次 if...else...？")])]),n._v(" "),a("p",[n._v("答案是：柯里化。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const handleOption = ((param) =>{\n     console.log('从始至终只用执行一次 if...else...')\n     if(param === 'A'){\n         return ()=>console.log('A')\n     }else{\n         return ()=>console.log('others')\n     }\n})\n\nconst tmp = handleOption('A')\n\ntmp()\ntmp()\ntmp()\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br")])]),a("p",[n._v("控制台打印：")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31bfa5c873fa40db891277b6aae449b1~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),n._v(" "),a("p",[n._v("这样的场景是有实战意义的，当我们做前端兼容时，经常要先判断是来源于哪个环境，再执行某个方法。比如说在 firefox 和 chrome 环境下，添加事件监听是 "),a("code",[n._v("addEventListener")]),n._v(" 方法，而在 IE 下，添加事件是 "),a("code",[n._v("attachEvent")]),n._v(" 方法；如果每次绑定这个监听，都要判断是来自于哪个环境，那肯定是很费劲。我们通过上述封装的方法，可以做到 "),a("strong",[n._v("一处判断，多次使用。")])]),n._v(" "),a("p",[n._v("肯定有小伙伴会问了：这也是柯里化？")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac991e34244a43469113a1d10d124730~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),n._v(" "),a("p",[n._v("嗯。。。怎么不算呢？")]),n._v(" "),a("p",[n._v("把 'A' 条件先固定下来，也可叫“缓存下来”，后续的函数执行将不再传 'A' 这个参数，实打实的：把多参数转化为单参数，逐个传递。")]),n._v(" "),a("h3",{attrs:{id:"缓存计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存计算"}},[n._v("#")]),n._v(" 缓存计算")]),n._v(" "),a("p",[n._v("我们再设想这样一个场景，现在有一个函数是来做大数计算的：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('const calculateFn = (num)=>{\n    const startTime = new Date()\n    for(let i=0;i<num;i++){} // 大数计算\n    const endTime = new Date()\n    console.log(endTime - startTime)\n    return "Calculate big numbers"\n}\n\ncalculateFn(10_000_000_000)\n')])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br")])]),a("p",[n._v("这是一个非常耗时的函数，复制代码在控制台看看，需要 8s+")]),n._v(" "),a("p",[n._v("如果业务代码中需要多次用到这个大数计算结果，多次调用 "),a("code",[n._v("calculateFn(10_000_000_000)")]),n._v(" 肯定是不明智的，太费时。")]),n._v(" "),a("p",[n._v("一般的做法就是声明一个全局变量，把运算结果保存下来:")]),n._v(" "),a("p",[n._v("比如 "),a("code",[n._v("const resNums = calculateFn(10_000_000_000)")])]),n._v(" "),a("p",[n._v("如果有多个大数运算呢？沿着这个思路，即声名多个变量：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const resNumsA = calculateFn(10_000_000_000)\nconst resNumsB = calculateFn(20_000_000_000)\nconst resNumsC = calculateFn(30_000_000_000)\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br")])]),a("p",[n._v("我们讲就是说："),a("strong",[n._v("奥卡姆剃刀原则 —— 如无必要、勿增实体。")])]),n._v(" "),a("p",[n._v("申明这么多全局变量，先不谈占内存、占命名空间这事，就把 "),a("code",[n._v("calculateFn()")]),n._v(" 函数的参数和声名的常量名一一对应，都是一个麻烦事。")]),n._v(" "),a("blockquote",[a("p",[n._v("有没有什么办法？只用函数，不增加多个全局常量，就实现多次调用，只计算一次？")])]),n._v(" "),a("p",[n._v("答案是：柯里化。")]),n._v(" "),a("p",[n._v("代码如下：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('function cached(fn){\n  const cacheObj = Object.create(null); // 创建一个对象\n  return function cachedFn (str) { // 返回回调函数\n    if ( !cacheObj [str] ) { // 在对象里面查询，函数结果是否被计算过\n        let result = fn(str);\n        cacheObj [str] = result; // 没有则要执行原函数，并把计算结果缓存起来\n    }\n    return cacheObj [str] // 被缓存过，直接返回\n  }\n}\n\nconst calculateFn = (num)=>{\n    console.log("计算即缓存")\n    const startTime = new Date()\n    for(let i=0;i<num;i++){} // 大数计算\n    const endTime = new Date()\n    console.log(endTime - startTime) // 耗时\n    return "Calculate big numbers"\n}\n\nlet cashedCalculate = cached(calculateFn) \n\nconsole.log(cashedCalculate(10_000_000_000)) // 计算即缓存 // 9944 // Calculate big numbers\nconsole.log(cashedCalculate(10_000_000_000)) // Calculate big numbers\n\nconsole.log(cashedCalculate(20_000_000_000)) // 计算即缓存 // 22126 // Calculate big numbers\nconsole.log(cashedCalculate(20_000_000_000)) // Calculate big numbers\n')])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br"),a("span",{staticClass:"line-number"},[n._v("26")]),a("br"),a("span",{staticClass:"line-number"},[n._v("27")]),a("br")])]),a("p",[n._v("这样只用通过一个 "),a("code",[n._v("cached")]),n._v(" 缓存函数的处理，所有的大数计算都能保证：输入参数相同的情况下，全局只用计算一次，后续可直接使用更加语义话的函数调用来得到之前计算的结果。")]),n._v(" "),a("p",[n._v("此处也是柯里化的应用，在 "),a("code",[n._v("cached")]),n._v(" 函数中先传需要处理的函数参数，后续再传入具体需要操作得值，将多参转化为单个参数逐一传入。")]),n._v(" "),a("h3",{attrs:{id:"缓存函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存函数"}},[n._v("#")]),n._v(" 缓存函数")]),n._v(" "),a("p",[n._v("柯里化的思想不仅可以缓存判断条件，缓存计算结果、缓存传参，还能缓存“函数”。")]),n._v(" "),a("p",[n._v("设想，我们有一个数字 7 要经过两个函数的计算，先乘以 10 ，再加 100，写法如下：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const multi10 = function(x) { return x * 10; }\nconst add100 = function(x) { return x + 100; }\nadd100(multi10(7))\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br")])]),a("p",[n._v("用柯里化处理后，即变成：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const multi10 = function(x) { return x * 10; }\nconst add100 = function(x) { return x + 100; }\nconst compose = function(f,g) { \n    return function(x) { \n        return f(g(x))\n    }\n}\n\ncompose(add100, multi10)(7)\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br")])]),a("p",[n._v("前者写法有两个传参是写在一起的，而后者则逐一传参。把最后的执行函数改写：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let compute = compose(add100, multi10)\n\ncompute(7)\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br")])]),a("p",[n._v("所以，这里的柯里化直接把函数处理给缓存了，当声明 compute 变量时，并没有执行操作，只是为了拿到 ()=> f(g(x))，最后执行 compute(7)，才会执行整个运算；")]),n._v(" "),a("hr"),n._v(" "),a("p",[n._v("怎么样？柯里化确实百变吧？柯里化的起源和闭包的定义是同宗同源。正如前文最开始所说，柯里化是闭包的一对“孪生子”。")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24b2c49607fc47988de69dc85e0cf95c~tplv-k3u1fbpfcp-watermark.image?",alt:"f5d872902efd115.gif"}})]),n._v(" "),a("p",[n._v("我们对闭包的解释：“闭包是一个函数内有另外一个函数，内部的函数可以访问外部函数的变量，这样的语法结构是闭包。”与我们对柯里化的解释“把接受多个参数的函数变换成接受一个单一参数（或部分）的函数，并且返回接受余下的参数和返回结果的新函数的技术”，这两种说法几乎是“等效的”，只是从不同角度对 "),a("em",[a("strong",[n._v("同一问题")])]),n._v(" 作出的解释，就像 lambda 演算和图灵机对希尔伯特第十问题的解释一样。")]),n._v(" "),a("p",[a("em",[n._v("同一问题")]),n._v("：指的是在 lambda 演算诞生之时，提出的：怎样用 lambda 演算实现接收多个参数？")]),n._v(" "),a("h2",{attrs:{id:"防抖与节流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#防抖与节流"}},[n._v("#")]),n._v(" 防抖与节流")]),n._v(" "),a("p",[n._v("好了，我们再来看看除了其它高阶函数中闭包思想（柯里化思想）的应用。首先是最最常用的防抖与节流函数。")]),n._v(" "),a("p",[n._v("防抖：就像英雄联盟的回城键，按了之后，间隔一定秒数才会执行生效。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function debounce(fn, delay) {\n    delay = delay || 200;\n    let timer = null;\n    return function() {\n        let arg = arguments;\n        // 每次操作时，清除上次的定时器\n        clearTimeout(timer);\n        timer = null;\n        // 定义新的定时器，一段时间后进行操作\n        timer = setTimeout(function() {\n            fn.apply(this, arg);\n        }, delay);\n    }\n};\n\nvar count = 0;\nwindow.onscroll = debounce(function(e) {\n    console.log(e.type, ++count); // scroll\n}, 500);\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br")])]),a("p",[n._v("节流函数：就像英雄联盟的技能键，是有 CD 的，一段时间内只能按一次，按了之后就要等 CD；")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 函数节流，频繁操作中间隔 delay 的时间才处理一次\nfunction throttle(fn, delay) {\n    delay = delay || 200;\n    let timer = null;\n    // 每次滚动初始的标识\n    let timestamp = 0;\n    return function() {\n        let arg = arguments;\n        let now = Date.now();\n        // 设置开始时间\n        if (timestamp === 0) {\n            timestamp = now;\n        }\n        clearTimeout(timer);\n        timer = null;\n        // 已经到了delay的一段时间，进行处理\n        if (now - timestamp >= delay) {\n            fn.apply(this, arg);\n            timestamp = now;\n        }\n        // 添加定时器，确保最后一次的操作也能处理\n        else {\n            timer = setTimeout(function() {\n                fn.apply(this, arg);\n                // 恢复标识\n                timestamp = 0;\n            }, delay);\n        }\n    }\n};\n\nvar count = 0;\nwindow.onscroll = throttle(function(e) {\n    console.log(e.type, ++count); // scroll\n}, 500);\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br"),a("span",{staticClass:"line-number"},[n._v("26")]),a("br"),a("span",{staticClass:"line-number"},[n._v("27")]),a("br"),a("span",{staticClass:"line-number"},[n._v("28")]),a("br"),a("span",{staticClass:"line-number"},[n._v("29")]),a("br"),a("span",{staticClass:"line-number"},[n._v("30")]),a("br"),a("span",{staticClass:"line-number"},[n._v("31")]),a("br"),a("span",{staticClass:"line-number"},[n._v("32")]),a("br"),a("span",{staticClass:"line-number"},[n._v("33")]),a("br"),a("span",{staticClass:"line-number"},[n._v("34")]),a("br"),a("span",{staticClass:"line-number"},[n._v("35")]),a("br")])]),a("p",[n._v("代码均可复制到控制台中测试。在防抖和节流的场景下，被预先固定住的变量是 "),a("code",[n._v("timer")]),n._v("。")]),n._v(" "),a("h2",{attrs:{id:"lodash-高阶函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lodash-高阶函数"}},[n._v("#")]),n._v(" lodash 高阶函数")]),n._v(" "),a("p",[n._v("lodash 大家肯定不陌生，它是最流行的 JavaScript 库之一，透过函数式编程模式为开发者提供常用的函数。")]),n._v(" "),a("p",[n._v("其中有一些封装的高阶函数，让一些平平无奇的普通函数也能有相应的高阶功能。")]),n._v(" "),a("p",[n._v("举几个例子：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 防抖动\n_.debounce(func, [wait=0], [options={}])\n// 节流\n_.throttle(func, [wait=0], [options={}])\n\n// 将一个断言函数结果取反\n_.negate(predicate) \n// 柯里化函数\n_.curry(func, [arity=func.length])\n// 部分应用\n_.partial(func, [partials])\n\n// 返回一个带记忆的函数\n_.memoize(func, [resolver])\n// 包装函数\n_.wrap(value, [wrapper=identity])\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br")])]),a("p",[n._v("研究源码你就会发现，_.debounce 防抖、_.throttle 节流上面说过，_.curry 柯里化上面说过、_.partial 在“缓存传参”里说过、_.memoize 在“缓存计算”里也说过......")]),n._v(" "),a("p",[n._v("再举一个例子：")]),n._v(" "),a("p",[n._v("现在要求一个函数在达到 n 次之前，每次都正常执行，第 n 次不执行。")]),n._v(" "),a("p",[n._v("也是非常常见的业务场景！JavaScript 实现：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function before(n, func) {\n  let result, count = n;\n  return function(...args) {\n    count = count - 1\n    if (count > 0) result = func.apply(this, args)\n    if (count <= 1) func = undefined\n    return result\n  }\n}\n\nconst fn= before(3,(x)=>console.log(x))\nfn(1) // 1\nfn(2) // 2\nfn(3) // 不执行\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br")])]),a("p",[n._v("反过来：函数只有到 n 次的时候才执行，n 之前的都不执行。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function after(n, func) {\n  let count = n || 0\n  return function(...args) {\n    count = count - 1\n    if (count < 1) return func.apply(this, args)\n  }\n}\n\nconst fn= after(3,(x)=>console.log(x))\nfn(1) // 不执行\nfn(2) // 不执行\nfn(3) // 3 \n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br")])]),a("p",[n._v("全是“闭包”、全是把参数“柯里化”。")]),n._v(" "),a("p",[n._v("细细体会，在控制台上敲一敲、改一改、跑一跑，下次或许你就可以自己写出这些有特定功能的高阶函数了。")]),n._v(" "),a("h2",{attrs:{id:"结语"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[n._v("#")]),n._v(" 结语")]),n._v(" "),a("p",[n._v("综合以上，可见由函数式启发的“闭包”、“柯里化”思想对 JavaScript 有多重要。几乎所有的高阶函数都离不开闭包、参数由多转逐一的柯里化传参思想。所在在很多面试中，都会问闭包，不管是一两年、还是三五年经验的前端程序员。定义一个前端的 JavaScript 技能是初级，还是中高级，这是其中很重要的一个判断点。")]),n._v(" "),a("blockquote",[a("p",[n._v("对闭包概念模糊不清的、或者只会背概念的 => 初级")]),n._v(" "),a("p",[n._v("会写防抖、节流、或柯里化等高阶函数的 => 中级")]),n._v(" "),a("p",[n._v("深刻理解高阶函数封装思想、能自主用闭包封装高阶函数 => 高级")])]),n._v(" "),a("p",[n._v("OK，以上便是本篇分享，专栏第 2 篇，希望各位工友喜欢~ 欢迎点赞、收藏、评论 🤟")]),n._v(" "),a("p",[n._v("后文会再深入 JavaScript 函数式编程，展开讲解：纯函数、延迟处理、JS 迭代器等、敬请期待~")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19d81d10e829483599b46d87e463535d~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),n._v(" "),a("p",[n._v("关注专栏 "),a("a",{attrs:{href:"https://juejin.cn/column/7140154838981017613",title:"https://juejin.cn/column/7140154838981017613",target:"_blank",rel:"noopener noreferrer"}},[n._v("# JavaScript 函数式编程精要 —— 签约作者安东尼"),a("OutboundLink")],1)]),n._v(" "),a("p",[n._v("我是掘金安东尼 🤠 100 万人气前端技术博主 💥 INFP 写作人格坚持 1000 日更文 ✍ 关注我，安东尼陪你一起度过漫长编程岁月 🌏")])])}),[],!1,null,null,null);s.default=t.exports}}]);