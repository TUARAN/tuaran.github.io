(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{580:function(n,s,a){"use strict";a.r(s);var e=a(2),t=Object(e.a)({},(function(){var n=this,s=n.$createElement,a=n._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("p",[n._v("接上一篇"),a("a",{attrs:{href:"https://juejin.cn/post/7034656546441297951",target:"_blank",rel:"noopener noreferrer"}},[n._v("《AVL 树旋转及 JS 实现，平衡树支棱起来~》"),a("OutboundLink")],1),n._v("，来了个难的，再来个相对简单的，别一直搁那“旋转树”而打击了“种二叉树”的自信心~~")]),n._v(" "),a("p",[n._v("日拱算法！冲！")]),n._v(" "),a("p",[a("a",{attrs:{href:"https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof",target:"_blank",rel:"noopener noreferrer"}},[n._v("题目"),a("OutboundLink")],1),n._v("：")]),n._v(" "),a("blockquote",[a("p",[n._v("输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。")])]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("示例 1:\n\n给定二叉树 [3,9,20,null,null,15,7]\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回 true 。\n\n示例 2:\n\n给定二叉树 [1,2,2,3,3,null,null,4,4]\n\n       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n返回 false 。\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br")])]),a("ul",[a("li",[n._v("限制：0 <= 树的结点个数 <= 10000")])]),n._v(" "),a("p",[a("strong",[n._v("解题思路：")])]),n._v(" "),a("p",[n._v("要验证一颗二叉树是否为平衡二叉树，只需要它的左子树是平衡二叉树，右子树是平衡二叉树，并且左右子树的深度差小于 2；")]),n._v(" "),a("p",[n._v("创建深度计算函数：")]),n._v(" "),a("p",[n._v("检测传入的树，如果为空，返回0，如果不为空，递归调用深度计算函数，分别计算左右子树的深度，将两个深度中的最大值 +1 作为结果返回；")]),n._v(" "),a("p",[n._v("创建平衡判断函数：")]),n._v(" "),a("p",[n._v("使用深度计算函数计算左右子树的深度，计算深度差，递归调用平衡；判断左右子树是否是平衡，如果深度差小于 2，且左右子树都平衡，返回 true，否则返回 false；")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("/**\n * 平衡判断函数\n */\nvar isBalanced = function(root) {\n    if(!root){\n        return true\n    }\n    // 计算左子树和右子树的深度差\n        // 判断左右子树是否平衡\n    return Math.abs(depth(root.left) - depth(root.right)) < 2 && isBalanced(root.left) && isBalanced(root.right)\n};\n\n/**\n * 深度计算函数\n */\nvar depth = function(root) {\n    if(!root) {\n        return 0\n    }\n    else {\n                // 取左右子树中深度比较大的值作为返回结果 +1\n        return Math.max(depth(root.left), depth(root.right)) + 1\n    }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br")])]),a("p",[n._v("反过来思考：")]),n._v(" "),a("p",[n._v("上面存在大量的重复计算，还可以使用从下向上的方式：")]),n._v(" "),a("p",[n._v("创建计算深度函数用于深度遍历树：")]),n._v(" "),a("p",[n._v("对左子树和右子树分别递归调用深度函数，计算深度，检测左右子树深度计算的结果，如果左子树的计算结果为 -1，返回 -1，如果右子树的计算结果为 -1，返回 -1，如果左右子树的深度差大于 1，返回 -1，检测通过，执行后续操作；")]),n._v(" "),a("p",[n._v("取左右子树中深度值较大的一个 +1，返回计算结果，调用计算深度函数，计算树，判断计算结果是否为 -1，如果是则二叉树不平衡，如果不是则二叉树平衡；")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var isBalanced = function(root) {\n    if(!root){return true}\n    return defs(root) !== -1\n};\n\n// 计算树的深度\nvar defs = function(node) {\n    if(!node) {\n        return 0\n    }\n    // 计算左子树深度\n    const left = defs(node.left)\n        // 计算右子树深度\n    const right = defs(node.right)\n    switch(true) {\n        // 如果左子树为 -1 则返回 -1\n        case left === -1:\n            return -1\n        // 如果右子树为 -1 则返回 -1\n        case right === -1:\n            return -1\n        // 如果左右子树的深度差大于1 则返回 -1\n        case Math.abs(left - right) > 1:\n            return -1\n        default:\n            // 取左右子树中深度较大的值 + 1 返回\n            return Math.max(left, right) + 1\n    }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br"),a("span",{staticClass:"line-number"},[n._v("26")]),a("br"),a("span",{staticClass:"line-number"},[n._v("27")]),a("br"),a("span",{staticClass:"line-number"},[n._v("28")]),a("br"),a("span",{staticClass:"line-number"},[n._v("29")]),a("br")])])])}),[],!1,null,null,null);s.default=t.exports}}]);