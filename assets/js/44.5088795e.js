(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{546:function(s,a,n){"use strict";n.r(a);var t=n(2),e=Object(t.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h2",{attrs:{id:"懒加载原理和实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#懒加载原理和实现"}},[s._v("#")]),s._v(" 懒加载原理和实现")]),s._v(" "),n("ul",[n("li",[s._v("原理：")])]),s._v(" "),n("p",[s._v("页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片，只有通过javascript设置了图片路径，浏览器才会发送请求。 懒加载的原理就是先在页面中把所有的图片统一使用一张占位图进行占位，把正真的路径存在元素的“data-url”（这个名字起个自己认识好记的就行）属性里，要用的时候就取出来，再设置为图片的真实src；")]),s._v(" "),n("ul",[n("li",[s._v("实现：")])]),s._v(" "),n("ol",[n("li",[s._v("首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。")]),s._v(" "),n("li",[s._v("页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。")]),s._v(" "),n("li",[s._v("在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。")])]),s._v(" "),n("ul",[n("li",[s._v("实现种类：")])]),s._v(" "),n("ol",[n("li",[s._v("第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟.")]),s._v(" "),n("li",[s._v("第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。")]),s._v(" "),n("li",[s._v("第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。")])]),s._v(" "),n("p",[s._v("第三类：e.g.")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("var imgs = document.getElementsByTagName('img');\n// 获取视口高度与滚动条的偏移量\nfunction lazyload(){\n    var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n    var viewportSize = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n    for(var i=0; i<imgs.length; i++) {\n\tvar x =scrollTop+viewportSize-imgs[i].offsetTop;\n\tif(x>0){\n\t    imgs[i].src = imgs[i].getAttribute('loadpic');   \n\t}\n    }\n}\nsetInterval(lazyload,1000);\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br")])]),n("h2",{attrs:{id:"预加载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#预加载"}},[s._v("#")]),s._v(" 预加载")]),s._v(" "),n("ul",[n("li",[s._v("原理")])]),s._v(" "),n("p",[s._v("让img 标签先显示其他的图片，当其指向的真实图片缓存完成后，再显示为实际的图片。")]),s._v(" "),n("ul",[n("li",[s._v("实现代码")])]),s._v(" "),n("p",[s._v("e.g.")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('function preLoadImg(url, callback) {\n    var img = new Image();\n    img.src = url;\n    //兼容ie、opera刷新页面时，不触发onload事件\n    if (img.complete) { // 如果图片已经存在于浏览器缓存，直接调用回调函数\n        callback(img);\n        return; // 直接返回，不用再处理onload事件\n    }\n    img.onload = function() { //图片下载完毕时异步调用callback函数。\n        callback(img);\n    };\n}\nwindow.onload = function() {\n    var arr = ["img/11.jpg", "img/12.jpg", "img/13.jpg"],\n        imgs = document.getElementsByTagName("img"),\n        len = imgs.length;\n    preLoadImg(arr[0], function(data) {\n        imgs[0].src = data.src;\n    });\n    preLoadImg(arr[1], function(data) {\n        imgs[1].src = data.src;\n    });\n};\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br")])]),n("p",[s._v("首先实例化一个Image对象赋值给img，然后设置img.src为参数url指定的图片地址,接着判断img的complete属性，如果本地有这张图片的缓存，则该值为true，此时我们可以直接操作这张图片，如果本地没有缓存，则该值为false，此时我们需要监听img的onload事件。")]),s._v(" "),n("h2",{attrs:{id:"渐进式加载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#渐进式加载"}},[s._v("#")]),s._v(" 渐进式加载")]),s._v(" "),n("ul",[n("li",[s._v("Baseline JPEG")])]),s._v(" "),n("p",[s._v("这种类型的JPEG文件存储方式是按从上到下的扫描方式，把每一行顺序的保存在JPEG文件中。"),n("strong",[s._v("打开这个文件显示它的内容时，数据将按照存储时的顺序从上到下一行一行的被显示出来")]),s._v("，直到所有的数据都被读完，就完成了整张图片的显示。如果文件较大或者网络下载速度较慢，那么就会看到图片被一行行加载的效果，这种格式的JPEG没有什么优点，因此，一般都推荐使用Progressive JPEG。")]),s._v(" "),n("ul",[n("li",[s._v("Progressive JPEG")])]),s._v(" "),n("p",[s._v("和Baseline JPEG一遍扫描不同，Progressive JPEG文件包含多次扫描，这些扫描顺寻的存储在JPEG文件中。"),n("strong",[s._v("打开文件过程中，会先显示整个图片的模糊轮廓，随着扫描次数的增加，图片变得越来越清晰")]),s._v("。这种格式的主要优点是在网络较慢的情况下，可以看到图片的轮廓知道正在加载的图片大概是什么。在一些网站打开较大图片时，你就会注意到这种技术。")]),s._v(" "),n("ul",[n("li",[s._v("实现方式")])]),s._v(" "),n("ol",[n("li",[s._v("在photoshop中有“存储为web所用格式”，打开后选择“连续”就是渐进式JPEG。")]),s._v(" "),n("li",[s._v("代码实现")])]),s._v(" "),n("h2",{attrs:{id:"对比"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对比"}},[s._v("#")]),s._v(" 对比")]),s._v(" "),n("table",[n("thead",[n("tr",[n("th",[s._v("类型")]),s._v(" "),n("th",[s._v("原理")])])]),s._v(" "),n("tbody",[n("tr",[n("td",[s._v("懒加载也叫延迟加载")]),s._v(" "),n("td",[s._v("JS 图片延迟加载,延迟加载图片或符合某些条件时才加载某些图片。迟缓甚至不加载，懒加载对服务器前端有一定的缓解压力作用")])]),s._v(" "),n("tr",[n("td",[s._v("预加载")]),s._v(" "),n("td",[s._v("提前加载图片，当用户需要查看时可直接从本地缓存中渲染。提前加载，预加载则会增加服务器前端压力。")])]),s._v(" "),n("tr",[n("td",[s._v("渐进式加载")]),s._v(" "),n("td",[s._v("通过图片的算法，实现先显示整个模糊轮廓，再逐渐变清晰。网络加载上没有任何变化。")])])])]),s._v(" "),n("ul",[n("li",[s._v("参考\n"),n("a",{attrs:{href:"https://lilywei739.github.io/2017/02/06/lazyload_Img.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("懒加载和预加载"),n("OutboundLink")],1)])]),s._v(" "),n("p",[n("a",{attrs:{href:"https://www.jianshu.com/p/d2817058c901",target:"_blank",rel:"noopener noreferrer"}},[s._v("使用渐进式 JPEG 来提升用户体验"),n("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=e.exports}}]);