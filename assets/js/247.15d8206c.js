(window.webpackJsonp=window.webpackJsonp||[]).push([[247],{743:function(n,s,a){"use strict";a.r(s);var t=a(2),e=Object(t.a)({},(function(){var n=this,s=n.$createElement,a=n._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("p",[n._v("携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第23天，"),a("a",{attrs:{href:"https://juejin.cn/post/7123120819437322247",title:"https://juejin.cn/post/7123120819437322247",target:"_blank",rel:"noopener noreferrer"}},[n._v("点击查看活动详情"),a("OutboundLink")],1)]),n._v(" "),a("hr"),n._v(" "),a("h2",{attrs:{id:"常见的算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的算法"}},[n._v("#")]),n._v(" 常见的算法")]),n._v(" "),a("p",[n._v("算法，通俗来讲，它是计算机通过一个固定的运算过程，将各类数据结构进行运算操作，得值的一种方法。算法也是程序员一定不能忽视的技能点。")]),n._v(" "),a("p",[n._v("这里将引入一些著名的算法进行介绍，每一个都是经典，值得收藏。")]),n._v(" "),a("h3",{attrs:{id:"排序算法-数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排序算法-数组"}},[n._v("#")]),n._v(" 排序算法（数组）")]),n._v(" "),a("p",[n._v("排序算法可能是最基础、最适合算法入门的经典算法，在面试中经常会问到排序算法及其相关的问题。有时会要求现场手写基本的排序算法。熟练掌握排序算法思想及其特点并能够熟练地手写代码至关重要。")]),n._v(" "),a("p",[n._v("我们经常会看到这样的文章标题，诸如：《十大经典排序算法详解》、《八大排序算法总结》，的确，排序算法有很多：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。")]),n._v(" "),a("p",[n._v("很明显这里不打算一一陈述，只讲其中最重点的 2 种排序方法，也是面试种被问过最多次的，它们是：冒泡排序和快速排序。")]),n._v(" "),a("ul",[a("li",[n._v("冒泡排序")])]),n._v(" "),a("p",[n._v("冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。")]),n._v(" "),a("p",[n._v("算法描述为：比较相邻的元素。如果第一个比第二个大，就交换它们两个；对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；针对所有的元素重复以上的步骤，除了最后一个；重复上述步骤，直到排序完成。")]),n._v(" "),a("p",[n._v("java 实现：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("public static void bubbleSort(int[] arr) {\n    int temp = 0;\n    for (int i = arr.length - 1; i > 0; i--) { // 每次需要排序的长度\n        for (int j = 0; j < i; j++) { // 从第一个元素到第i个元素\n            if (arr[j] > arr[j + 1]) {\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }//loop j\n    }//loop i\n}// method bubbleSort\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br")])]),a("ul",[a("li",[n._v("快速排序")])]),n._v(" "),a("p",[n._v("快速排序是一个知名度极高的排序算法，其对于大数据的优秀排序性能和相同复杂度算法中相对简单的实现使它注定得到比其他算法更多的宠爱。")]),n._v(" "),a("p",[n._v('算法描述为：从数列中挑出一个元素，称为"基准"，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区操作。然后再递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。')]),n._v(" "),a("p",[n._v("java 实现：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("public static void quickSort(int[] arr){\n    qsort(arr, 0, arr.length-1);\n}\nprivate static void qsort(int[] arr, int low, int high){\n    if (low >= high)\n        return;\n    int pivot = partition(arr, low, high);        //将数组分为两部分\n    qsort(arr, low, pivot-1);                   //递归排序左子数组\n    qsort(arr, pivot+1, high);                  //递归排序右子数组\n}\nprivate static int partition(int[] arr, int low, int high){\n    int pivot = arr[low];     //基准\n    while (low < high){\n        while (low < high && arr[high] >= pivot) --high;\n        arr[low]=arr[high];             //交换比基准大的记录到左端\n        while (low < high && arr[low] <= pivot) ++low;\n        arr[high] = arr[low];           //交换比基准小的记录到右端\n    }\n    //扫描完成，基准到位\n    arr[low] = pivot;\n    //返回的是基准的位置\n    return low;\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br")])]),a("p",[n._v("快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。")]),n._v(" "),a("h3",{attrs:{id:"二分查找-数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二分查找-数组"}},[n._v("#")]),n._v(" 二分查找（数组）")]),n._v(" "),a("p",[n._v("除了排序算法，二分查找也是算法中的基础经典面试题。它是一种查找算法，适用于在已经排好序的数组中找到一个特定的值。")]),n._v(" "),a("p",[n._v("算法思路是：找到数组的中间元素坐标并记录，将需要查找的元素跟中间元素进行比较，如果大于中间元素，则截取中间元素以后的所有元素作为新的数组，将中间元素设为新数组的起始元素，如果小于中间元素，则截取中间元素以前的所有元素作为新的数组。")]),n._v(" "),a("p",[n._v("然后再在新的数组中找到中间元素，继续进行比较，如果中间元素等于目标值则返回输出。")]),n._v(" "),a("p",[n._v("java 实现：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("public static int binarySearch(int[] arr, int value) {\n        int min = 0;\n        int max = arr.length - 1;\n        while (min <= max) {\n            int mid = (max + min) >>1;\n            if (arr[mid] == value) {\n                return mid;\n            }\n            if (value < arr[mid]) {\n                max = mid - 1;\n            }\n            if (value > arr[mid]) {\n                min = mid + 1;\n            }\n        }\n        return -1;\n    }\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br")])]),a("p",[n._v("二分法的效率高，而且也比较便捷，用起来更方便~")]),n._v(" "),a("h3",{attrs:{id:"dfs-和-bfs-树-图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dfs-和-bfs-树-图"}},[n._v("#")]),n._v(" DFS 和 BFS（树/图）")]),n._v(" "),a("p",[n._v("深度优先遍历（简称 DFS）与广度优先遍历（简称 BFS）是图论中两种非常重要的算法，生产上广泛用于拓扑排序，寻路（走迷宫），搜索引擎，爬虫等，也频繁出现在 leetcode，高频面试题中。")]),n._v(" "),a("p",[n._v("也广泛应用在树这类数据结构的遍历场景，从根本上来讲，树也是一种特殊的图，连通无环的图就是树。")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/142e13750a914704bd473f1617ab82e9~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),n._v(" "),a("ul",[a("li",[n._v("深度优先遍历")])]),n._v(" "),a("p",[n._v("深度优先遍历主要思路是从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底，不断递归重复此过程，直到所有的顶点都遍历完\n成，它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走。")]),n._v(" "),a("p",[n._v("在上图中，遍历过程将是：第一次遍历（节点 1、2、5、9） 第二次遍历（3、6、10）、第三次遍历（7）、第四次遍历（4、8）")]),n._v(" "),a("p",[n._v("深度优先遍历有递归和非递归两种方式，此处给出递归的 java 代码示例：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("public class Solution {\n    private static class Node {\n        public int value;\n        public Node left;\n        public Node right;\n        public Node(int value, Node left, Node right) {\n            this.value = value;\n            this.left = left;\n            this.right = right;\n        }\n    }\n    public static void dfs(Node treeNode) {\n        if (treeNode == null) {\n            return;\n        }\n        // 遍历节点\n        process(treeNode)\n        // 遍历左节点\n        dfs(treeNode.left);\n        // 遍历右节点\n        dfs(treeNode.right);\n    }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br")])]),a("p",[n._v("递归的表达性很好，也很容易理解，不过如果层级过深，很容易导致栈溢出。")]),n._v(" "),a("p",[n._v("思考：你知道非递归的怎么写吗？提示是用栈实现。")]),n._v(" "),a("ul",[a("li",[n._v("广度优先遍历")])]),n._v(" "),a("p",[n._v("广度优先遍历，指的是从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点。")]),n._v(" "),a("p",[n._v("广度优先遍历也叫层序遍历，同样的，在上图所示的树中，先遍历第一层（节点 1），再遍历第二层（节点 2、3、4），第三层（5、6、7、8），第四层（9、10）。")]),n._v(" "),a("p",[n._v("广度优先遍历可以用队列实现，java 代码如下：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('/**\n * 使用队列实现 bfs\n * @param root\n */\nprivate static void bfs(Node root) {\n    if (root == null) {\n        return;\n    }\n    Queue<Node> stack = new LinkedList<>();\n    stack.add(root);\n\n    while (!stack.isEmpty()) {\n        Node node = stack.poll();\n        System.out.println("value = " + node.value);\n        Node left = node.left;\n        if (left != null) {\n            stack.add(left);\n        }\n        Node right = node.right;\n        if (right != null) {\n            stack.add(right);\n        }\n    }\n}\n')])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br")])]),a("p",[n._v("小结：DFS 和 BFS 是非常重要的两种算法，大家一定要掌握，本文为了方便讲解，只对树做了 DFS，BFS，大家可以试试如果用图的话该怎么写代码，原理其实也是一样，只不过图和树两者的表示形式不同而已，DFS 一般是解决连通性问题，而 BFS 一般是解决最短路径问题。")]),n._v(" "),a("h3",{attrs:{id:"狄克斯特拉算法-图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#狄克斯特拉算法-图"}},[n._v("#")]),n._v(" 狄克斯特拉算法（图）")]),n._v(" "),a("p",[n._v("狄克斯特拉（Dijkstra）算法是非常著名的算法，是改变世界的十大算法之一，是典型最短路径算法，计算一个起始节点到路径中其他所有节点的最短路径的算法和思想。在一些专业课程中如数据结构，图论，运筹学等都有介绍。其思想是一种基础的求最短路径的算法，通过基础思想的变化可以解决很多复杂问题，如导航线路，动态规划等。")]),n._v(" "),a("p",[n._v("举个例子：在下图中，以 A 点为顶点，求到其他点的最短路径。")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/674cbb2b20a34625b7b07968a5e0ab36~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),n._v(" "),a("p",[n._v("思路是：每次从“未求出最短路径”的点中 取出“距离距离起点”最小路径的点，以这个点为桥梁刷新“求出最短路径的点”的距离。")]),n._v(" "),a("p",[n._v("比如 A 点到 B 点距离为 2，A 点到 D 点的距离为 6，A 点到 C 点的距离未知，所以以 B 点为桥梁，再去计算刷新距离。")]),n._v(" "),a("p",[n._v("B 点到 C 点，距离为3；B 到 D 点距离为 2 ，通过计算 A 以 B 为桥梁，A 到 B 再到 D 的距离为 4 ，比 A 直接到 D 的距离 6 更短，刷新原有值；")]),n._v(" "),a("p",[n._v("同时，更新桥梁点 D 点，因为 B 到 D 比 B 到 C 要更近，依次经过 A、B、D、C 距离为 6 ，大于原来依次经过的 A、B、C 的距离 5，不用刷新原值，即 A 到 C 最近为 5；")]),n._v(" "),a("p",[n._v("以上即全部思路：最终结果 A 到 B 最近为 2；A 到 D 最近为 4；A 到 C 最近为 5；")]),n._v(" "),a("p",[n._v("java 代码实现：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("public class Dijkstra {\n    public static int[] dijkstra(int[][] graph,int startVertex){\n        //初始化 以求出最短路径的点 result[]\n        int length = graph.length;\n        int[] result = new int[length];\n        for (int i = 0; i < length; i++) {\n            result[i] = -1;\n        }\n        result[startVertex] = 0 ;\n        // 初始化 未求出最短路径的点 notFound[]\n        int[] notFound = new int[length];\n        for (int i = 0; i < length; i++) {\n            notFound[i] = graph[startVertex][i];\n        }\n        notFound[startVertex] = -1;\n        // 开始 Dijkstra 算法\n        for (int i = 1; i < length; i++) {\n            //1. 从「未求出最短路径的点」notFound 中取出 最短路径的点\n            //1.1 找到最短距离的点\n            int min = Integer.MAX_VALUE;\n            int minIndex = 0;\n            for (int j = 0; j < length; j++) {\n                if (notFound[j] > 0 && notFound[j] < min){\n                    min = notFound[j];\n                    minIndex = j;\n                }\n            }\n            //1.2 将最短距离的点 取出 放入结果中\n            result[minIndex] = min;\n            notFound[minIndex] = -1;\n            //2. 刷新 「未求出最短距离的点」 notFound[] 中的距离\n            //2.1 遍历刚刚找到最短距离的点 (B) 的出度 (BA、BB、BC、BD)\n            for (int j = 0; j < length; j++) {\n                // 出度可通行(例如 BD:graph[1][3]  > 0)\n                // 出度点不能已经在结果集 result中(例如 D: result[3] == -1)\n                if (graph[minIndex][j] > 0\n                && result[j] == -1){\n                    int newDistance = result[minIndex] + graph[minIndex][j];\n                    //通过 B 为桥梁，刷新距离\n                    //（比如`AD = 6 < AB + BD = 4` 就刷新距离）（ -1 代表无限大）\n                    if (newDistance < notFound[j] || notFound[j]==-1){\n                        notFound[j] = newDistance;\n                    }\n                }\n            }\n\n        }\n        return result;\n    }\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br"),a("span",{staticClass:"line-number"},[n._v("26")]),a("br"),a("span",{staticClass:"line-number"},[n._v("27")]),a("br"),a("span",{staticClass:"line-number"},[n._v("28")]),a("br"),a("span",{staticClass:"line-number"},[n._v("29")]),a("br"),a("span",{staticClass:"line-number"},[n._v("30")]),a("br"),a("span",{staticClass:"line-number"},[n._v("31")]),a("br"),a("span",{staticClass:"line-number"},[n._v("32")]),a("br"),a("span",{staticClass:"line-number"},[n._v("33")]),a("br"),a("span",{staticClass:"line-number"},[n._v("34")]),a("br"),a("span",{staticClass:"line-number"},[n._v("35")]),a("br"),a("span",{staticClass:"line-number"},[n._v("36")]),a("br"),a("span",{staticClass:"line-number"},[n._v("37")]),a("br"),a("span",{staticClass:"line-number"},[n._v("38")]),a("br"),a("span",{staticClass:"line-number"},[n._v("39")]),a("br"),a("span",{staticClass:"line-number"},[n._v("40")]),a("br"),a("span",{staticClass:"line-number"},[n._v("41")]),a("br"),a("span",{staticClass:"line-number"},[n._v("42")]),a("br"),a("span",{staticClass:"line-number"},[n._v("43")]),a("br"),a("span",{staticClass:"line-number"},[n._v("44")]),a("br"),a("span",{staticClass:"line-number"},[n._v("45")]),a("br"),a("span",{staticClass:"line-number"},[n._v("46")]),a("br"),a("span",{staticClass:"line-number"},[n._v("47")]),a("br"),a("span",{staticClass:"line-number"},[n._v("48")]),a("br"),a("span",{staticClass:"line-number"},[n._v("49")]),a("br")])]),a("p",[n._v("狄克斯特拉算法值得每个关注数据结构算法的程序员重点关注。")]),n._v(" "),a("h3",{attrs:{id:"lru-哈希"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lru-哈希"}},[n._v("#")]),n._v(" LRU（哈希）")]),n._v(" "),a("p",[n._v("LRU 算法是一种缓存淘汰算法，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”，所以将其保存。反之就意味着，如果数据最近最少被访问，就优先被清除。")]),n._v(" "),a("p",[n._v("一般来讲，LRU 将访问数据的顺序或时间和数据本身维护在一个容器当中。")]),n._v(" "),a("p",[n._v("当访问一个数据时：该数据不在容器当中，则设置该数据的优先级为最高并放入容器中。该数据在容器当中，则更新该数据的优先级至最高。当数据的总量达到上限后，则移除容器中优先级最低的数据。")]),n._v(" "),a("p",[n._v("在 java 中可以直接根据 JDK 给我们提供的 LinkedHashMap 直接实现 LRU。有兴趣自行了解 LinkedHashMap 底层原理。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("public class LRUCache extends LinkedHashMap {\n    private int capacity;\n    public LRUCache(int capacity) {\n        // accessOrder 设为 true\n        super(16, 0.75f, true); \n        this.capacity = capacity;\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry eldest) {\n        return super.size() >= capacity;\n    }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br")])]),a("p",[n._v("虽然上面这些算法有些看来略显晦涩，但是实实在在应用在我们程序世界的每一处，每一个起到了独当一面的作用。值得我们在学习数据结构中，关注这些经典算法。")]),n._v(" "),a("hr"),n._v(" "),a("blockquote",[a("p",[n._v("OK，以上便是本篇分享。点赞关注评论，为好文助力👍")]),n._v(" "),a("p",[n._v("我是掘金安东尼 🤠 100 万人气前端技术博主 💥 INFP 写作人格坚持 1000 日更文 ✍ 关注我，安东尼陪你一起度过漫长编程岁月 🌏")])])])}),[],!1,null,null,null);s.default=e.exports}}]);