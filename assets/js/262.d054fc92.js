(window.webpackJsonp=window.webpackJsonp||[]).push([[262],{756:function(a,v,t){"use strict";t.r(v);var _=t(2),e=Object(_.a)({},(function(){var a=this,v=a.$createElement,t=a._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究!")]),a._v(" "),t("h2",{attrs:{id:"专栏简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#专栏简介"}},[a._v("#")]),a._v(" 专栏简介")]),a._v(" "),t("blockquote",[t("p",[a._v("作为一名 5 年经验的 JavaScript 技能拥有者，笔者时常在想，它的核心是什么？后来我确信答案是：闭包和异步。而函数式编程能完美串联了这两大核心，从高阶函数到函数组合；从无副作用到延迟处理；从函数响应式到事件流，从命令式风格到代码重用。所以，本专栏将从函数式编程角度来再看 JavaScript 精要，欢迎关注！"),t("a",{attrs:{href:"https://juejin.cn/column/7140154838981017613",target:"_blank",rel:"noopener noreferrer"}},[a._v("签约专栏-传送门"),t("OutboundLink")],1),a._v(" —— 掘金安东尼")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4bf96cff62241a2b5d96a89d90cfa88~tplv-k3u1fbpfcp-watermark.image?",alt:"1663211942306.png"}})]),a._v(" "),t("h2",{attrs:{id:"本篇序言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本篇序言"}},[a._v("#")]),a._v(" 本篇序言")]),a._v(" "),t("p",[a._v("本瓜很喜欢看历史，读史可知兴替、使人明智，作为程序员看“技术的演替历史”同样如此。过程是越看越有味，仿佛先贤智慧的光照亮了我原本封闭的心，每每只能感叹一个“服”字。所以，专栏第一篇打算先从技术历史讲起，从函数式编程的渊源讲起。")]),a._v(" "),t("p",[a._v("看完本篇：")]),a._v(" "),t("p",[a._v("你会知道为什么有人会说 "),t("strong",[a._v("“计算机是数学家一次失败思考的产物”")]),a._v("；")]),a._v(" "),t("p",[a._v("你会知道为什么 "),t("strong",[a._v("“ lambda 演算定义函数有效计算”")]),a._v(" ；")]),a._v(" "),t("p",[a._v("你会知道编程概念中 "),t("strong",[a._v("“闭包最初是如何形成的”")]),a._v("；")]),a._v(" "),t("p",[a._v("你还会知道为什么标题要说 "),t("strong",[a._v("“JavaScript 基因里写着函数式编程”")]),a._v(" ；")]),a._v(" "),t("p",[a._v("话不多说，开冲了~ 🏃‍🏃‍🏃‍")]),a._v(" "),t("h2",{attrs:{id:"一、数学之美"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、数学之美"}},[a._v("#")]),a._v(" 一、数学之美")]),a._v(" "),t("p",[a._v("函数式编程的历史最早可以追溯到 1930 年，一个叫 丘奇（Church）的人，提出了 λ （lambda）演算，这是所有函数式编程语言的基础。")]),a._v(" "),t("p",[a._v("那这人为啥要提出这个演算？1930 年这个时间比世界上第一台计算机诞生的时间都还要早 16 年。提出这个肯定不是因为计算机编程。")]),a._v(" "),t("p",[a._v("没错，他是为了解决一个数学问题。")]),a._v(" "),t("p",[a._v("这个数学问题是：")]),a._v(" "),t("p",[t("strong",[a._v("著名的希尔伯特第十问题—— 判定问题")]),a._v(" （1900 年提出）")]),a._v(" "),t("p",[a._v("我们不妨来“浅看”一下这个数学问题，可以说这个问题促使了计算机的形成。")]),a._v(" "),t("blockquote",[t("p",[a._v("什么是希尔伯特第十问题之判定问题？")])]),a._v(" "),t("p",[a._v("本瓜尝试用通俗的表达解释一下：")]),a._v(" "),t("p",[a._v("很简单，有下列这样一个方程：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a716843d342432bbb68d266335e6f06~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),t("p",[a._v("其中所有的数（a"),t("sub",[a._v("j")]),a._v("、b"),t("sub",[a._v("j")]),a._v("、c）都是整数，求：能否找到一组 x"),t("sub",[a._v("j")]),a._v(" （全部为整数）的解？")]),a._v(" "),t("p",[a._v("乍一看这个公式有点费解。。。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27ea81412b7240b792f19bcadfd122cd~tplv-k3u1fbpfcp-watermark.image?",alt:"1663225189166.png"}})]),a._v(" "),t("p",[a._v("其实我们可以构建一个大家都熟悉的实例，保证一看就明白了~")]),a._v(" "),t("p",[a._v("请问："),t("strong",[a._v("x"),t("sup",[a._v("2")]),a._v("+y"),t("sup",[a._v("2")]),a._v("=z"),t("sup",[a._v("2")])]),a._v("  // 这个方程，有整数解吗？")]),a._v(" "),t("p",[a._v("我敲，这不就是勾股定理吗？勾三股四弦五，老祖宗在西周时就发现了。")]),a._v(" "),t("p",[t("strong",[a._v("符合判定问题的实例方程还有很多")]),a._v("，比如：裴蜀等式、佩尔方程、四平方和定理、以及著名的【费马大猜想】等等。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b19383a243444f190ca874b2c784535~tplv-k3u1fbpfcp-watermark.image?",alt:"20220427113727_4f921.gif"}})]),a._v(" "),t("p",[a._v("噢！希尔伯特提出判定问题，旨在“一劳永逸”，如果这个问题被解决了，那么它的子问题也都能被同样解决。所以，在 1900 年到 1930 年之间，以希尔伯特为代表的数学家们 "),t("strong",[a._v("试图构建一个自动化定理证明的系统")]),a._v("，让公理系统内的所有命题都能用一套既定的规则得以证明或证伪。")]),a._v(" "),t("p",[a._v("说白了，就是这群数学家也想偷懒，证明各类数学公式已经累了，想搞点自动化的通用流程，能够用通用流程去证明或证伪数学难题。")]),a._v(" "),t("p",[a._v("大家都在前赴后继的尝试解决这个问题，直到 1930 年后，出现了 "),t("strong",[a._v("哥德尔、图灵、丘奇")]),a._v(" 这些人，他们几乎在同一时间，但又在不同角度对这个问题作出了解释。")]),a._v(" "),t("p",[a._v("更为神奇的是，最终证明他们的结论竟然是等效的。")]),a._v(" "),t("p",[t("strong",[a._v("哥德尔不完备性定理中递归函数 == 图灵完备 == lambda 演算")])]),a._v(" "),t("p",[a._v("他们彻底解决了希尔伯特第十问题吗？")]),a._v(" "),t("p",[a._v("很遗憾，并没有。")]),a._v(" "),t("p",[a._v("不过在这个过程中，他们搞清楚了一个很重要的问题，一个对计算机科学至关重要的元核心问题：")]),a._v(" "),t("blockquote",[t("p",[t("strong",[a._v("什么样的函数是可以有效计算的？！")])])]),a._v(" "),t("p",[a._v("在这之前，数学家们对于这个问题并没有一个普遍结论，只知道一些最简单的函数，以及通过简单规则将简单函数组合起来的函数（比如加法），是可以有效计算的。")]),a._v(" "),t("p",[a._v("这种感觉像是无心插柳，本来大家是冲着解决数学公式论证问题去的，最后不约而同的得出了“函数可有效计算”的定义。这个定义由此发展，成为了 21 世纪最具颠覆力量的学科 —— 计算机。")]),a._v(" "),t("p",[a._v("所以才有人说：计算机是数学家一次失败思考的产物。")]),a._v(" "),t("p",[a._v("数学的局限也会造成计算机的局限。")]),a._v(" "),t("p",[a._v("不过依然无法掩盖数学之美，美在它足够基础，但又隐藏着巨大的能量，影响着万事万物。")]),a._v(" "),t("h2",{attrs:{id:"二、lambda-演算核心"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、lambda-演算核心"}},[a._v("#")]),a._v(" 二、lambda 演算核心")]),a._v(" "),t("blockquote",[t("p",[a._v("各位，你有想过，什么样的函数是可以有效计算的？")])]),a._v(" "),t("p",[a._v("如果由你定义，你会从怎样的角度去思考？")]),a._v(" "),t("ul",[t("li",[a._v("由于本篇重点是讲函数式编程起源的 lambda 演算，所以哥德尔和图灵的解释不作展开，在文尾有相关文章推荐，可自行了解。（尤其是图灵机，一定多看看、体会体会）")])]),a._v(" "),t("p",[a._v("丘奇给出了它的观点：")]),a._v(" "),t("blockquote",[t("p",[a._v("有效计算的函数指的是：函数每一步都可被事先确定，而且该函数可在有限的步数之内生成结果。")])]),a._v(" "),t("p",[a._v("通俗来理解，“有效”即要在有限步骤内产生确定的结果。")]),a._v(" "),t("p",[a._v("天才的丘奇给出了 lambda 演算表达式：")]),a._v(" "),t("blockquote",[t("p",[t("strong",[a._v("lambda x . body")])])]),a._v(" "),t("p",[a._v("其中 x 是输入的参数，body 是运算过程，意思是 x 经过 body 的运算，然后返回结果。")]),a._v(" "),t("p",[a._v("lambda 演算的伟大之处在于它非常简洁，揭示了计算的本质。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ed1d26c39724d3f8c7d94a4b388234d~tplv-k3u1fbpfcp-watermark.image?",alt:"1663487715586.png"}})]),a._v(" "),t("p",[a._v("细看 lambda 表达式，你会发现函数只能接受一个参数，如果我们需要传两个参数呢？")]),a._v(" "),t("p",[a._v("其实也是能实现的，如下：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("lambda x. ( lambda y. plus x y )\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("这就是沿用至今的函数式编程 "),t("strong",[a._v("柯里化")]),a._v(" 思想，传入参数 x，经过运算体 body："),t("code",[a._v("lambda y. plus x y")]),a._v(" 的运算，body 又是一个 lambda 运算表达式，入参是 y，新的运算体是 "),t("code",[a._v("plus x y")]),a._v("。")]),a._v(" "),t("p",[a._v("这种简化的设计，让我们无需过多的语法，便能实现接收多个参数。")]),a._v(" "),t("p",[t("strong",[a._v("lambda 演算核心还有两条重要的规则：转换 和 规约")])]),a._v(" "),t("ul",[t("li",[a._v("转换")])]),a._v(" "),t("p",[a._v("转换的意思是：变量的名称并不重要，比如以下两种写法是等效的，相当于变量名只是形参而已。")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("lambda x. ( lambda y. plus x y )\n\nlambda y. ( lambda x. plus x y )\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br")])]),t("ul",[t("li",[a._v("规约")])]),a._v(" "),t("p",[a._v("规约的意思是：我们可以对这个函数体中和对应函数标识符相关的部分做替换，替换方法是把标识符用参数值替换。")]),a._v(" "),t("p",[a._v("举个例子：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("(lambda x . x + 1) 3\n\n// 规约后\n\n3 + 1\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("p",[a._v("这样写意味着 3 是形参 x 实际的值，数值“3”可直接取代引用的参数“x”，规约后即为 "),t("code",[a._v("3 + 1")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("(lambda y . (lambda x . x + y)) q\n\n// 规约后\nlambda x . x + q\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("p",[a._v("首先 q 是形参 y 实际的值，规约后，实际上就是求 "),t("code",[a._v("lambda x . x + q")])]),a._v(" "),t("p",[a._v("规约远能做的很多变化，正是由于规约的存在，让 lambda 演算可以实现递归，才让它可以等效于图灵完备。")]),a._v(" "),t("p",[a._v("我们再来概括一下：")]),a._v(" "),t("ol",[t("li",[a._v("lambda 核心表达式：lambda x . body，简洁而优雅；")]),a._v(" "),t("li",[a._v("入参只有一个，可以通过柯里化来实现接受多个参数；")]),a._v(" "),t("li",[a._v("lambda 演算的“规约”规则是它实现复杂运算的重要机制，由繁化简；")]),a._v(" "),t("li",[a._v("多问一句：把函数作为 body 返回，不正是 JavaScript 高阶函数的意思吗？")])]),a._v(" "),t("p",[a._v("可见，现在很多我们觉得稀松平常的一些用法，其实早在近 100 年前就被提出来了，不可谓不震撼。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dca7fbd6f204dcfb5e93967d9548763~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),t("h2",{attrs:{id:"三、javascript-的基因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、javascript-的基因"}},[a._v("#")]),a._v(" 三、JavaScript 的基因")]),a._v(" "),t("p",[a._v("说了半天，终于来到了我们的 JavaScript，相信大家接触 JavaScript 之初都会被“闭包”这个概念搞得有点蒙，为什么要这样设计？我平常又确实用不上，好不容易学了个防抖、节流函数，你就不要再继续追问“什么是闭包了”。")]),a._v(" "),t("p",[a._v("兄弟，有福了，这次带你见识最初的闭包是如何产生的！")]),a._v(" "),t("p",[a._v("闭包的概念，在计算机诞生之前就被设计出来了，没错，还是来源于我们的 lambda 演算。")]),a._v(" "),t("p",[a._v("lambda 演算规定：")]),a._v(" "),t("blockquote",[t("p",[a._v("如果一个标识符是一个闭合 lambda 表达式的参数，我们则称这个标识符是被绑定的；如果一个标识符在任何封闭的上下文中都没有绑定，那么它被称为自由变量。")])]),a._v(" "),t("p",[a._v("比如：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("lambda x . plus x y\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("在这个表达式中，x是被绑定的，因为它是函数定义的闭合表达式 plus x y 的参数。而 y 是自由变量；")]),a._v(" "),t("p",[a._v("再比如：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("lambda y . (lambda x . plus x y)\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("在内层演算 lambda x . plus x y 中，x 是被绑定的，y 是自由的；而在完整表达中，x 和 y 是都是被绑定的：x 受内层绑定，而 y 由剩下的外层演算绑定。")]),a._v(" "),t("p",[t("strong",[a._v("这正是 JavaScript 闭包最初的雏形，")]),a._v(" 内部函数保持着对函数外部变量的引用。这里“被绑定的”意思就是变量不能被清理的，是以后会被用到的。")]),a._v(" "),t("p",[a._v("神奇吗？闭包早于计算机诞生，仿佛就像打火机早于火柴发明一样，让人有点意外~")]),a._v(" "),t("hr"),a._v(" "),t("p",[a._v("好了，最后说一说：为什么 JavaScript 基因里写着函数式编程 ？")]),a._v(" "),t("p",[a._v("这一段历史，应该很多工友早烂熟于心，网景公司想给 HTML 加一个脚本语言用于改善交互，于是招来了 布兰登·艾克，这老哥 10 天就把这门语言的框架设计好了。它思想上基于 Self 语言和 Scheme 语言，语法上和 C 语言相似。")]),a._v(" "),t("p",[a._v("我们再看这里的 Scheme 语言，它其实就是一门堂堂正正的函数式编程语言，它是第一大函数式编程语言 Lisp （1958 年）两种方言的其中一种。而 Lisp 则来源于 lambda 演算，来源于 丘奇，来源于那个解决 1900 年数学问题的意外收获！")]),a._v(" "),t("p",[a._v("时间线是这样的：")]),a._v(" "),t("ul",[t("li",[a._v("=> 1900 年希尔伯特数学问题")]),a._v(" "),t("li",[a._v("=> 1930 年丘奇 lambda 演算")]),a._v(" "),t("li",[a._v("=> 1958 年 Lisp 语言")]),a._v(" "),t("li",[a._v("=> 1975 年 Scheme 语言")]),a._v(" "),t("li",[a._v("=> 1995 年 JavaScript 语言")])]),a._v(" "),t("blockquote",[t("p",[a._v("知道从哪里来，才能知道往哪里去。")])]),a._v(" "),t("p",[a._v("所以，朋友们，我们现在所用的 JavaScript，基因里有一个重要的组成部分是函数式，把函数放在第一位、关注输入输出、参数柯里化、高级函数等等，在近百年里逐渐演进。前段时间，看到一篇文章，JSON 之父吐槽说：现在我们更关注于把 JavaScript 的使用规模扩大，而不是关注怎样使这门语言变得更好。然后导致他建议退役 JavaScript，我大受震撼。或许，如果某一天，ES 版本迭代关注点只有：又新增了几个语法糖，而忽略了这门语言最初的设计思想，忽略去完善它，那真有点可惜。")]),a._v(" "),t("p",[a._v("OK，以上便是本篇分享，专栏第 1 篇，希望各位工友喜欢~ 欢迎点赞、收藏、评论 🤟")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/265b327076c3433e9689c318a21e637b~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),t("p",[a._v("关注专栏 "),t("a",{attrs:{href:"https://juejin.cn/column/7140154838981017613",target:"_blank",rel:"noopener noreferrer"}},[a._v("# JavaScript 函数式编程精要 —— 签约作者安东尼"),t("OutboundLink")],1)]),a._v(" "),t("blockquote",[t("p",[a._v("我是掘金安东尼 🤠 100 万人气前端技术博主 💥 INFP 写作人格坚持 1000 日更文 ✍ 关注我，安东尼陪你一起度过漫长编程岁月 🌏")])]),a._v(" "),t("h2",{attrs:{id:"推荐阅读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#推荐阅读"}},[a._v("#")]),a._v(" 推荐阅读")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://www.changhai.org/articles/science/mathematics/hilbert10/1.php",target:"_blank",rel:"noopener noreferrer"}},[a._v("Hilbert 第十问题漫谈 (上) - changhai"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E4%B8%9F%E7%95%AA%E5%9C%96%E6%96%B9%E7%A8%8B",target:"_blank",rel:"noopener noreferrer"}},[a._v("丢番图方程 - wikipedia"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://zh.m.wikipedia.org/zh-hans/%E9%82%B1%E5%A5%87%EF%BC%8D%E5%9B%BE%E7%81%B5%E8%AE%BA%E9%A2%98",target:"_blank",rel:"noopener noreferrer"}},[a._v("邱奇－图灵论题 - wikipedia"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B",target:"_blank",rel:"noopener noreferrer"}},[a._v("函数式编程 - wikipedia"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://www.zhihu.com/question/21936396",target:"_blank",rel:"noopener noreferrer"}},[a._v("‘λ演算’是什么？- zhihu"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://www.zhihu.com/question/20773904/answer/2272685195",target:"_blank",rel:"noopener noreferrer"}},[a._v("图灵机与λ演算是等价的 - zhihu"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://blog.csdn.net/pongba/article/details/1336028",target:"_blank",rel:"noopener noreferrer"}},[a._v("永恒的金色对角线-刘未鹏"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6923013950565154824",target:"_blank",rel:"noopener noreferrer"}},[a._v("停机问题"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=e.exports}}]);