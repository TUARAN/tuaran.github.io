(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{554:function(n,s,e){"use strict";e.r(s);var a=e(2),t=Object(a.a)({},(function(){var n=this,s=n.$createElement,e=n._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("没错，本篇是上一篇"),e("a",{attrs:{href:"https://juejin.cn/post/7026987512543313934",target:"_blank",rel:"noopener noreferrer"}},[n._v("《好的，BFS，又学废了！》"),e("OutboundLink")],1),n._v("的姊妹篇，意在通过简单回顾拾起学了忘、又忘了学的基础数据结构；")]),n._v(" "),e("p",[e("strong",[n._v("DFS")]),n._v("，全称是：深度优先遍历（Depth_First_Search），通常和 BFS 广度优先遍历（Breadth-first search）对比理解学习；")]),n._v(" "),e("p",[n._v("还记得，前篇最后小结中的一句话：")]),n._v(" "),e("blockquote",[e("p",[n._v("BFS，是一种利用队列实现的搜索算法。（与之相对的 DFS 是用栈来处理）")])]),n._v(" "),e("p",[n._v("没错！再次强化理解：")]),n._v(" "),e("ul",[e("li",[n._v("DFS 采用的是"),e("strong",[n._v("栈")]),n._v("的形式, 即先进后出；")]),n._v(" "),e("li",[n._v("BFS 则采用的是"),e("strong",[n._v("队列")]),n._v("的形式, 即先进先出；")])]),n._v(" "),e("p",[n._v("深度优先不需要记住所有的节点, 所以占用空间小, 而广度优先需要先记录所有的节点占用空间大；")]),n._v(" "),e("p",[n._v("题外话：需要的空间大，则需要的时间就更少；占用的空间小，则需要的时间就更多，时间换空间，或者空间换时间；可以联想到，在函数式编程和非函数式编程中也有这个思想，FP语言所占内存大，惰性求值，时间上，计算更快、更合理；非FP语言，所占内存小，变量频繁修改，所占内存小，但时间消耗更多；")]),n._v(" "),e("p",[n._v("OK，一图胜千言：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33afc42fd2594285b9b7fd6fb867ff70~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),n._v(" "),e("p",[n._v("可以看到，DFS 深度优先遍历不像 BFS 广度优先遍历那样逐层遍历，而是 "),e("strong",[n._v("“一条路上走到黑”、“不撞南墙不回头”")]),n._v(" 的态势纵向遍历所有的子节点，再返回兄弟节点，再遍历兄弟节点的子节点，直接全部遍历结束；")]),n._v(" "),e("p",[n._v("小例子仍然以遍历 DOM 树为需求，用 DFS 解：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('function deepFirstSearch(node) {\n    var nodes = [];\n    if (node != null) {\n        var stack = []; // 栈！\n        stack.push(node); // 入栈 \n        while (stack.length != 0) {\n        var item = stack.pop(); // 将最后一个元素出栈\n        nodes.push(item); // 推到结果数组\n        var children = item.children;\n        for (var i = children.length - 1; i >= 0; i--)\n            stack.push(children[i]); // 子元素入栈\n        }\n    }\n    return nodes;\n}\n\ndeepFirstSearch(document.getElementsByTagName("body")[0])\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br")])]),e("p",[n._v("递归实现：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('function deepFirstSearch(node,nodeList) {  \n    if (node) {    \n        nodeList.push(node);    \n        var children = node.children;    \n        for (var i = 0; i < children.length; i++) \n        //每次递归的时候将 需要遍历的节点 和 节点所存储的数组传下去\n        deepFirstSearch(children[i],nodeList);    \n    }    \n    return nodeList;  \n} \ndeepFirstSearch(document.getElementsByTagName("body")[0],[])\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br")])]),e("p",[n._v("为了更加明显的对比，贴出之前 BFS 的解：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('function breadthFirstSearch(node) {  \n    var nodes = [];  \n    if (node != null) {  \n        var queue = [];  \n        queue.unshift(node); // 将初始节点放入队中\n        while (queue.length != 0) {\n            var item = queue.shift(); // 提取队首元素\n            nodes.push(item);\n            var children = item.children; \n            for (var i = 0; i < children.length; i++) // 遍历全部子元素\n                queue.push(children[i]);  // 推入队中\n        }  \n    }  \n    return nodes;  \n}\n\nbreadthFirstSearch(document.getElementsByTagName("body")[0])\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br")])]),e("p",[n._v("递归实现：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('function breadthFirstSearch(node,nodes) {\n    if (!(node == null)) {\n        nodes.push(node);\n        breadthFirstSearch(node.nextElementSibling,nodes); // 优先遍历兄弟节点\n        breadthFirstSearch(node.firstElementChild,nodes); // 再遍历子节点\n    }\n    return nodes;\n}\nbreadthFirstSearch(document.getElementsByTagName("body")[0],[])\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br")])]),e("p",[n._v("综上，需谨记："),e("strong",[n._v("DFS-栈、BFS-队列")]),n._v("；")]),n._v(" "),e("p",[n._v("简单来道题吧："),e("a",{attrs:{href:"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"}},[n._v("二叉树的最大深度"),e("OutboundLink")],1)]),n._v(" "),e("blockquote",[e("p",[n._v("给定一个二叉树，找出其最大深度。")]),n._v(" "),e("p",[n._v("二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。")]),n._v(" "),e("p",[e("strong",[n._v("说明:")]),n._v(" 叶子节点是指没有子节点的节点。")])]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回它的最大深度 3 。\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br")])]),e("p",[n._v("思路：节点为空时说明高度为 0，所以返回 0；节点不为空时则分别求左右子树的高度的最大值，同时加1表示当前节点的高度，返回该数值；")]),n._v(" "),e("p",[n._v("递归解：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(!root) {\n        return 0;\n    } else {\n        const left = maxDepth(root.left);\n        const right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n};\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br")])]),e("p",[n._v("时间复杂度：O(n)")]),n._v(" "),e("p",[n._v("递归解二叉树，yyds！")]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("BFS 和 DFS 是很重要的算法，BFS 的重点在于队列，而 DFS 的重点在于递归；它们在搜素领域有非常大的发挥空间。")]),n._v(" "),e("blockquote",[e("p",[n._v('BFS 常用于找单一的最短路线，它的特点是 "搜到就是最优解"，而 DFS 用于找所有解的问题，它的空间效率高，而且找到的不一定是最优解，必须记录并完成整个搜索，故一般情况下，深搜需要非常高效的剪枝；'),e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/345181624",target:"_blank",rel:"noopener noreferrer"}},[n._v("什么是算法中的剪枝？"),e("OutboundLink")],1)])]),n._v(" "),e("p",[n._v("OK，以上就是本次分享；")]),n._v(" "),e("p",[e("strong",[n._v("我是掘进安东尼，公众号同名，日拱一卒、日掘一金，明天再会~")])])])}),[],!1,null,null,null);s.default=t.exports}}]);