(window.webpackJsonp=window.webpackJsonp||[]).push([[154],{651:function(a,s,e){"use strict";e.r(s);var t=e(2),n=Object(t.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究!")]),a._v(" "),e("h2",{attrs:{id:"专栏简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#专栏简介"}},[a._v("#")]),a._v(" 专栏简介")]),a._v(" "),e("blockquote",[e("p",[a._v("作为一名 5 年经验的 JavaScript 技能拥有者，笔者时常在想，它的核心是什么？后来我确信答案是：闭包和异步。而函数式编程能完美串联了这两大核心，从高阶函数到函数组合；从无副作用到延迟处理；从函数响应式到事件流，从命令式风格到代码重用。所以，本专栏将从函数式编程角度来再看 JavaScript 精要，欢迎关注！"),e("a",{attrs:{href:"https://juejin.cn/column/7140154838981017613",title:"https://juejin.cn/column/7140154838981017613",target:"_blank",rel:"noopener noreferrer"}},[a._v("传送门"),e("OutboundLink")],1)])]),a._v(" "),e("h2",{attrs:{id:"前文回顾"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前文回顾"}},[a._v("#")]),a._v(" 前文回顾")]),a._v(" "),e("p",[a._v("不知不觉，专栏已经来到第 5 篇~ 😍😍😍")]),a._v(" "),e("p",[a._v("前 4 篇传送门、时间线及概要：")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/7144851873411891207",target:"_blank",rel:"noopener noreferrer"}},[a._v("# ✨从历史讲起，JavaScript 基因里写着函数式编程"),e("OutboundLink")],1),a._v("  - 2022年09月19日")]),a._v(" "),e("p",[a._v("=> JavaScript 闭包起源于 1930 年的 lambda 运算；")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/7147454421822078984",target:"_blank",rel:"noopener noreferrer"}},[a._v("# ✨从柯里化讲起，一网打尽 JavaScript 重要的高阶函数"),e("OutboundLink")],1),a._v(" - 2022年09月26日")]),a._v(" "),e("p",[a._v("=> 将函数作为参数输入或输出，是封装高级函数的核心思想；")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/7152279659969773598",target:"_blank",rel:"noopener noreferrer"}},[a._v("# ✨从纯函数讲起，一窥最深刻的函子 Monad"),e("OutboundLink")],1),a._v(" - 2022年10月09日")]),a._v(" "),e("p",[a._v("=> 写无副作用的纯函数不只是为了嘴上说说优雅，而是为了函数的组合、演算简化、及自文档等好处；")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/7153394937961119752",target:"_blank",rel:"noopener noreferrer"}},[a._v("# ✨从延迟处理讲起，JavaScript 也能惰性编程？"),e("OutboundLink")],1),a._v(" - 2022年10月12日")]),a._v(" "),e("p",[a._v("=> 延迟处理是连接 JavaScript 闭包和异步两大核心的桥梁，JavaScript 真万能，惰性编程一样拿捏；")]),a._v(" "),e("p",[a._v("OK，至于本篇，将从异步讲起，看看「JS 异步」和 「函数式」能擦出什么样的火花？看看异步中的时间与函数该作何关系？")]),a._v(" "),e("h2",{attrs:{id:"探秘-js-异步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#探秘-js-异步"}},[a._v("#")]),a._v(" 探秘 JS 异步")]),a._v(" "),e("blockquote",[e("p",[a._v("JavaScript 除了“闭包”这个最经典的设计之外，还有它是“单线程”的设计，一样可奉为最经典！")])]),a._v(" "),e("p",[a._v("这里先抛出 3 个经典的问题：")]),a._v(" "),e("ol",[e("li",[a._v("“JavaScript 为什么要是单线程？”")]),a._v(" "),e("li",[a._v("“JavaScript 的单线程，意味着什么？”")]),a._v(" "),e("li",[a._v("“JavaScipt 异步原理是怎么实现的？”")])]),a._v(" "),e("p",[a._v("如果你能清晰准确地回答出这3个关于异步老生常谈的经典问题，可以跳过下一小节的释义。")]),a._v(" "),e("h3",{attrs:{id:"经典-3-问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#经典-3-问"}},[a._v("#")]),a._v(" 经典 3 问")]),a._v(" "),e("p",[a._v("先浅答一下 JS 异步经典 3 问 ~")]),a._v(" "),e("blockquote",[e("ol",[e("li",[a._v("“JavaScript 为什么要是单线程？”")])])]),a._v(" "),e("p",[a._v("答：四字概括，为了：“简单方便”。JavaScript 最初设计只是运行在浏览器的脚本语言，若同一时间要做多件事情便会产生矛盾；不像其它后端语言用“锁”这样一个机制，也为了极致简单，所以 JavaScript 设计是单线程的。")]),a._v(" "),e("blockquote",[e("ol",{attrs:{start:"2"}},[e("li",[a._v("“JavaScript 的单线程，意味着什么？”")])])]),a._v(" "),e("p",[a._v("答：单线程意味着任务需要排队，任务是一个接一个地执行，前一个执行完毕，才会执行下一个。这就意味着前一个任务的执行会阻塞后续任务的执行。")]),a._v(" "),e("p",[a._v("好比去银行办理业务，目前只有一个人工窗口，前面有个人要办理大额贷款业务，需要填写很多表格，只有等这人把全部表格都填完，整个流程都走完，才能让后面的人接着办业务。")]),a._v(" "),e("p",[a._v("现实中如果发生这样的事，肯定要被投诉，哪有这样设计的？让后面这么多人干等他填表格，并且这个时候窗口服务也是停止的，那效率得多低呀。")]),a._v(" "),e("p",[a._v("所以，正确的做法是，先将这个人挪到一边，让他去填表格，把窗口服务腾出来给后面的人继续办业务，等表格填完了，再回过头来给你办理大额贷款。")]),a._v(" "),e("p",[a._v("将这个比喻映射到 JavaScript 也是同样的逻辑，JavaScript 通过异步来解决单线程阻塞的问题。这也是 "),e("strong",[a._v("与生俱来")]),a._v(" 就已经设定好了的（和闭包一样，都写在 DNA 里）。")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1511134f65a34ab386f606d014d33cee~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),e("blockquote",[e("ol",{attrs:{start:"3"}},[e("li",[a._v("“JavaScipt 异步原理是怎么实现的？”")])])]),a._v(" "),e("p",[a._v("答：JS 引擎通过混用 2 种内存数据结构："),e("strong",[a._v("栈和队列")]),a._v(" 来实现异步。栈与队列的交互也就是大家所熟知的 JS 事件循环（Event Loop）。")]),a._v(" "),e("p",[a._v("简单来讲：所有同步任务都是在主线程上执行的，形成 "),e("strong",[a._v("执行栈")]),a._v("，异步任务的回调消息形成 "),e("strong",[a._v("回调队列")]),a._v("。在执行栈中的任务处理完成后，主线程就开始读取任务队列中的任务并执行。按这个规则，不断往复循环。")]),a._v(" "),e("p",[a._v("上一张经典的图：")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87cb834262ed41aab214bd6338915f44~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),e("p",[a._v("这里的 Stack 就相当于是前面所提银行场景中的唯一人工窗口，Stack 里面的任务就是等待办业务的人，遇到办大额贷款、填很多表格的人，则先挪到一边去，然后继续处理后面人的业务。若这人表格全填完了，就把这个消息放到 CallBack queue 里，等 Stack 里为空后，再去拿 callBack queue 的消息，继续为你解决大额贷款。")]),a._v(" "),e("p",[a._v("以上三问，老生常谈，温故知新。")]),a._v(" "),e("h3",{attrs:{id:"新-3-问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#新-3-问"}},[a._v("#")]),a._v(" 新 3 问")]),a._v(" "),e("p",[a._v("好了，老 3 问只是开始的小结，这里本瓜要问异步新 3 问：")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("“JavaScript 实现异步有哪几种表现形式？”")])]),a._v(" "),e("li",[e("p",[a._v("“JavaScript 异步和函数式有什么关系？”")])]),a._v(" "),e("li",[e("p",[a._v("“JavaScript 异步真的简单吗？”")])])]),a._v(" "),e("p",[a._v("在脑袋里面简单过一过你的答案？")]),a._v(" "),e("p",[a._v("。。。。。。")]),a._v(" "),e("p",[a._v("下面来逐一详细解答~~")]),a._v(" "),e("h3",{attrs:{id:"异步演进"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步演进"}},[a._v("#")]),a._v(" 异步演进")]),a._v(" "),e("blockquote",[e("ol",[e("li",[a._v("“JavaScript 实现异步有哪几种表现形式？”")])])]),a._v(" "),e("p",[a._v("答：")]),a._v(" "),e("p",[a._v("① 回调函数")]),a._v(" "),e("p",[a._v("最简单实现异步就是使用回调函数。")]),a._v(" "),e("p",[a._v("打个比方，以打电话给客服为例，你有两种选择：排队等待客服接听 或 选择客服有空时回电给你。")]),a._v(" "),e("p",[a._v("后面一种就是回调 —— CallBack")]),a._v(" "),e("p",[a._v("🌰代码示例：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('function success(res){\n    console.log("API call successful");\n}\n\nfunction fail(err){\n    console.log("API call failed");\n}\n\nfunction callApiFoo(success, fail){\n    fetch(url)\n      .then(res => success(res))\n      .catch(err => fail(err));\n};\n\ncallApiFoo(success, fail);\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br")])]),e("p",[a._v("回调缺点就是：嵌套调用会形成 "),e("strong",[a._v("回调地狱")]),a._v("，加大代码的阅读难度，比如：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("callApiFooA((resA)=>{\n    callApiFooB((resB)=>{\n        callApiFooC((resC)=>{\n            console.log(resC);\n        }), fail);\n    }), fail);\n}), fail);\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br")])]),e("p",[a._v("② Promise")]),a._v(" "),e("p",[a._v("为了弥补回调函数的不足，ES6 将异步方案改进为 Promise。")]),a._v(" "),e("p",[a._v("🌰用代码说话，上述“回调地狱”优化为：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function callApiFooA(){\n    return fetch(url); // JS fetch method returns a Promise\n}\n\nfunction callApiFooB(resA){\n    return fetch(url+'/'+resA.id);  \n}\n\nfunction callApiFooC(resB){\n    return fetch(url+'/'+resB.id);  \n}\n\ncallApiFooA()\n    .then(callApiFooB)\n    .then(callApiFooC)\n    .catch(fail)\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br")])]),e("p",[a._v("Promise 也有缺点，当状态处于 pending 时，不知道程序执行到哪一步了，无法中途取消，这一点前面的文章也提到过。")]),a._v(" "),e("p",[a._v("③ Generator")]),a._v(" "),e("p",[a._v("于是 Generator 生成器函数异步解决方案诞生。")]),a._v(" "),e("p",[a._v("🌰代码变化：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function *makeIterator() {\n   let resA = fetch(url)\n   yield resA\n   let resB = fetch(url+'/'+resA.id)\n   yield resB\n   let resC = fetch(url+'/'+resB.id)\n   yield resC\n}\nvar it = makeIterator()\n\nit.next() // callApiFooA\nit.next() // callApiFooB\nit.next() // callApiFooC\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br")])]),e("p",[a._v("再后来，ES2017 提出 async await 是 Generator 语法糖，不做赘述。")]),a._v(" "),e("p",[a._v("一般来说，写道 async await ，JS 异步演进就结束了，但，不止于此，还有一种，是本节的亮点，即“响应式”。")]),a._v(" "),e("p",[a._v("④ 响应式")]),a._v(" "),e("p",[a._v("处理多个异步操作数据流是很复杂的，尤其是当它们之间相互依赖时，我们可以用更巧妙地方式将它们组合：响应式处理异步，Observer 登场！")]),a._v(" "),e("p",[a._v("🌰 show me the code:")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" function callApiFooA(){\n    return fetch(urlA); \n } \n \n function callApiFooB(){\n    return fetch( urlB );  \n }\n \n function callApiFooC( [resAId, resBId] ){\n    return fetch(url +'/'+ resAId +'/'+ resBId);  \n } \n \n function callApiFooD( resC ){\n    return fetch(url +'/'+ resC.id);  \n } \n \n Observable.from(Promise.all([callApiFooA() , callApiFooB() ])).pipe(\n    map(([resA, resB]) => ([resA.id, resB.id])), // <- extract ids\n    switchMap((resIds) => Observable.from(callApiFooC( resIds ) )),\n    switchMap((resC) => Observable.from(callApiFooD( resC ) )),\n    tap((resD) => console.log(resD))\n).subscribe();\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br"),e("span",{staticClass:"line-number"},[a._v("20")]),e("br"),e("span",{staticClass:"line-number"},[a._v("21")]),e("br"),e("span",{staticClass:"line-number"},[a._v("22")]),e("br")])]),e("p",[a._v("同步请求 A、B 两个接口，然后把结果作为请求 C 的参数，然后把请求 C 的返回作为请求 D，最后打印请求 D 的结果。")]),a._v(" "),e("p",[a._v("这里用到一些大家可能陌生的新的 api，需稍作解释：")]),a._v(" "),e("ul",[e("li",[a._v("Observable.from 将一个 Promises 数组转换为 Observable，它是基于 callApiFooA 和 callApiFooB 的结果数组；")]),a._v(" "),e("li",[a._v("map — 从 API 函数 A 和 B 的 Respond 中提取 ID；")]),a._v(" "),e("li",[a._v("switchMap — 使用前一个结果的 id 调用 callApiFooC，并返回一个新的 Observable，新 Observable 是 callApiFooC( resIds ) 的返回结果；")]),a._v(" "),e("li",[a._v("switchMap — 使用函数 callApiFooC 的结果调用 callApiFooD；")]),a._v(" "),e("li",[a._v("tap — 获取先前执行的结果，并将其打印在控制台中；")]),a._v(" "),e("li",[a._v("subscribe — 开始监听 observable；")])]),a._v(" "),e("p",[a._v("Observable 是多数据值的生产者，它在处理异步数据流方面更加强大和灵活。它在 Angular 等前端框架中被使用。")]),a._v(" "),e("p",[a._v("这样做有何好处？核心好处是分离 "),e("strong",[a._v("创建（发布）")]),a._v("  和 "),e("strong",[a._v("调用（订阅消费）")]),a._v(" 。")]),a._v(" "),e("p",[a._v("异步与回调的核心意义不正在于此吗？我订阅你的博客，你发布了新内容，于是就通知我这边，好了，这样一来，我也不用干等，只要你发布了新的文章，我就可以按照自己的方式来消费它们。各干各的。并且我消费的方式可以是花里胡哨的，可以坐着看、躺着看、上班看、睡觉前看、拉屎看，与你发布无关。")]),a._v(" "),e("h3",{attrs:{id:"异步和函数式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步和函数式"}},[a._v("#")]),a._v(" 异步和函数式")]),a._v(" "),e("blockquote",[e("ol",{attrs:{start:"2"}},[e("li",[a._v("“JavaScript 异步和函数式有什么关系？”")])])]),a._v(" "),e("p",[a._v("有关系吗？")]),a._v(" "),e("p",[a._v("异步是解决单线程设计的堵塞的，函数式是 JavaScript 的基因其中一种。二者似乎没关系？")]),a._v(" "),e("p",[a._v("错，二者有关系，并且关系莫大，粗略分为 3 点：")]),a._v(" "),e("p",[a._v("① 组合特性")]),a._v(" "),e("p",[a._v("在函数式编程中，我们把函数组合当作是重点之一，将函数的声明和函数的组合调用分开。每个函数的功能职责单一，最大范围内保持数据的不变性、数据计算的易追踪。")]),a._v(" "),e("p",[a._v("在异步解决方案中，我们也尽量将对异步操作的先后关系确定清楚，谁和谁一起执行、谁先执行谁后执行、谁等待谁的结果，这些也是在调用过程中有很多操作的地方，与声明隔开。在调用时组合好，数据流沿着时间维度演变。")]),a._v(" "),e("p",[a._v("② 代码可读性")]),a._v(" "),e("p",[a._v("异步从回调地狱到 Promise，到 Generator，到 async await，是为了啥？不就是为了代码读起来更易读吗？")]),a._v(" "),e("p",[a._v("那函数式也是，从无副作用的纯函数，清晰可见地控制输入输出，再到函数组合，演算，也是为了更可读。")]),a._v(" "),e("p",[a._v("可谓："),e("strong",[a._v("二者志同而道和")])]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6190119bb16e465794e91f04e416aecf~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),e("p",[a._v("③ 函数响应式编程")]),a._v(" "),e("p",[a._v("有一种编程方式就叫：函数响应式编程，你说二者什么关系？")]),a._v(" "),e("blockquote",[e("p",[a._v("函数式响应式编程(FRP) 是一种编程范式，它采用函数式编程的基础部件（如map、reduce、filter等），进行响应式编程（异步数据流程编程）。FRP被用于GUI、机器人和音乐方面的编程，旨在通过显式的建模时间来简化这些问题。—— wikipedia")])]),a._v(" "),e("p",[a._v("通俗来讲，函数响应式编程是面向离散事件流的，在一个时间轴上会产生一些离散事件，这些事件会依次向下传递。")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3c93e043c934bfd857c73d55d77e0d3~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),e("p",[a._v("如图所示，点击一个按钮事件，随着时间推移，这个点击事件会产生三个不同的结果：")]),a._v(" "),e("ul",[e("li",[a._v("值")]),a._v(" "),e("li",[a._v("发生错误")]),a._v(" "),e("li",[a._v("事件完成")])]),a._v(" "),e("p",[a._v("我们可以定义方法用来：捕获值，捕获错误，捕获点击事件结束。")]),a._v(" "),e("p",[a._v("对应代码上的，就涉及几个基础概念：")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("Observable（可观察对象） ：就是点击事件流。")])]),a._v(" "),e("li",[e("p",[a._v("Observers（观察者） ：就是捕获值/错误/事件结束的方法（其实就是回调函数集合)。")])]),a._v(" "),e("li",[e("p",[a._v("Subscription（订阅） ：Observable 产生的值都需要通过一个‘监听’把值传给 Observers，这个‘监听’就是 Subscription。")])]),a._v(" "),e("li",[e("p",[a._v("Producer（生产者）：就是点击事件，是事件的生产者。")])])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("--a---b-c---d---X---|->\n\na b c d 是产生的值\nX 是错误\n| 是事件结束标志\n---\x3e 是时间线\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("p",[a._v("在前端交互非常复杂的系统中，客户端都是基于事件编程的，对事件处理非常多，在这样的场景下， "),e("strong",[a._v("函数响应式编程可以更加有效率地处理事件流，而无需管理状态")]),a._v("。能量强大。")]),a._v(" "),e("h3",{attrs:{id:"异步与时间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步与时间"}},[a._v("#")]),a._v(" 异步与时间")]),a._v(" "),e("blockquote",[e("ol",{attrs:{start:"3"}},[e("li",[a._v("“JavaScript 异步真的简单吗？”")])])]),a._v(" "),e("p",[a._v("想一想，JavaScript 异步的设计真的就是简单吗？")]),a._v(" "),e("p",[a._v("“给你一段同步代码，有 10 个函数方法调用” 和 “给你一段同步加异步的代码，其中 5 个函数方法是同步、5 个函数方法是异步”，你觉得其中哪个会更易理解？")]),a._v(" "),e("p",[a._v("毫无疑问，控制其它变量，尽量选择有更多同步代码的会更易理解。")]),a._v(" "),e("p",[a._v("为什么？因为异步就代表着先后时间关系，代表着复杂！")]),a._v(" "),e("blockquote",[e("p",[a._v("在你所有的应用里，最复杂的状态就是时间。当你操作的数据状态改变过程比较直观的时候，是很容易管理的。但是，如果状态随着时间因为响应事件而隐晦的变化，管理这些状态的难度将会成几何级增长。")])]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a58b4c18d2b64db6983bdd8098dbc650~tplv-k3u1fbpfcp-watermark.image?",alt:"1666663944950.png"}})]),a._v(" "),e("p",[a._v("很多情况下我们调试错误发现最终原因是因为异步处理的回调先后关系出错。")]),a._v(" "),e("p",[e("strong",[a._v("所以，异步并不简单。")])]),a._v(" "),e("p",[a._v("怎样才简单？这里提供 3 个方法，简单释义：")]),a._v(" "),e("p",[a._v("① 减少时间状态")]),a._v(" "),e("p",[a._v("不喜欢时间是吧，那就异步转同步，减少时间状态，promise 或者 async await 就是一个很好的例子。")]),a._v(" "),e("p",[a._v("② 监听（惰性）")]),a._v(" "),e("p",[a._v("设置监听，就不用管时间啦，这也是另外一种消除时间状态的方法。")]),a._v(" "),e("p",[a._v("我们在 Vue 这种框架中用生命周期、钩子函数、各类监听，正是如此，不用再管具体时间先后，框架已经帮我们限定好了，按照它的规则处理即可。")]),a._v(" "),e("p",[a._v("③ 函数响应式编程")]),a._v(" "),e("p",[a._v("函数响应式编程是更规范、更高级的让异步更简单的方案。")]),a._v(" "),e("p",[a._v("用纯函数、用表达式、用组合、分离 生产者 和 消费者 、用更强大的封装 API，代码各司其职，可以很大程度上提高代码的可读性和维护性。")]),a._v(" "),e("h2",{attrs:{id:"结语"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[a._v("#")]),a._v(" 结语")]),a._v(" "),e("p",[a._v("为什么是异步？因为我们不想浪费因同步等待阻塞的时间。")]),a._v(" "),e("p",[a._v("但是你时间又总给函数带来困惑，异步中，我要沿着时间线不断去追溯你，协调因响应先后不同带来的差异。")]),a._v(" "),e("p",[a._v("状态随着时间发生隐晦的变化，管理这些状态，难度成几何级增长。")]),a._v(" "),e("p",[a._v("代码的可靠性？可预见性？又该从何而得？")]),a._v(" "),e("p",[a._v("时间，时间，请给函数以答案？")]),a._v(" "),e("p",[a._v("。。。。。。")]),a._v(" "),e("p",[a._v("相信你认真看完本篇会有一点想法和答案~~")]),a._v(" "),e("hr"),a._v(" "),e("p",[a._v("OK，以上便是本篇分享，专栏第 5 篇，希望各位工友喜欢~ 欢迎点赞、收藏、评论 🤟")]),a._v(" "),e("p",[a._v("本篇侧重在理论释义，后续会带来 FRP 实战、以及 JS Monad、RxJS 等进阶内容，敬请期待~")]),a._v(" "),e("p",[a._v("关注专栏 "),e("a",{attrs:{href:"https://juejin.cn/column/7140154838981017613",title:"https://juejin.cn/column/7140154838981017613",target:"_blank",rel:"noopener noreferrer"}},[a._v("# JavaScript 函数式编程精要 —— 签约作者安东尼"),e("OutboundLink")],1)]),a._v(" "),e("blockquote",[e("p",[a._v("我是掘金安东尼 🤠 100 万人气前端技术博主 💥 INFP 写作人格坚持 1000 日更文 ✍ 关注我，安东尼陪你一起度过漫长编程岁月 🌏")])])])}),[],!1,null,null,null);s.default=n.exports}}]);