(window.webpackJsonp=window.webpackJsonp||[]).push([[181],{677:function(e,n,s){"use strict";s.r(n);var a=s(2),t=Object(a.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),s("p",[e._v("什么是 FRP？")]),e._v(" "),s("p",[e._v("英文全称是："),s("strong",[e._v("Functional Reactive Programming")]),e._v("，翻译过来就是："),s("strong",[e._v("函数响应式编程")]),e._v("。")]),e._v(" "),s("p",[e._v("对于函数式编程，我们并不陌生，在 "),s("a",{attrs:{href:"https://juejin.cn/column/6960836897669120036",target:"_blank",rel:"noopener noreferrer"}},[e._v("我的 JS 专栏"),s("OutboundLink")],1),e._v(" 里面可以找到很多相关文章~~")]),e._v(" "),s("p",[e._v("这里不妨先对函数式编程特性做简要回顾：")]),e._v(" "),s("ol",[s("li",[e._v("函数是一等公民"),s("sub",[e._v("（意味着可以把函数赋值给变量或存储在数据结构中，也可以把函数作为其它函数的参数或者返回值）")])]),e._v(" "),s("li",[e._v("高阶函数"),s("sub",[e._v("（接受函数作为参数或者返回一个函数的函数）")])]),e._v(" "),s("li",[e._v("没有隐式输入、输出"),s("sub",[e._v("（输入通过函数入参传递，输出通过函数 return 进行返回）")])]),e._v(" "),s("li",[e._v("值的不变性"),s("sub",[e._v("（指在程序状态改变时，不直接修改当前数据，而是创建并追踪一个新数据）")])]),e._v(" "),s("li",[e._v("声明式编程风格，而不是命令式编程风格"),s("sub",[e._v("（关注“是什么”，而不是“做什么”）")])])]),e._v(" "),s("p",[e._v("用代码举个简单例子：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 命令式编程\nint factorial1(int x) {\n    int result = 1;\n    for (int i = 1; i <= x; i ++) {\n        result *= i;\n    }\n    return result;\n}\n\n// 函数式编程\nint factorial2(int x) {\n    if (x == 1) return 1;\n    return x * factorial2(x - 1);\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br")])]),s("p",[e._v("以上代码用于实现计算阶乘。指令式编程，像机器一条条命令一样思考问题，一条条指令告诉计算机该怎么去处理这个问题。")]),e._v(" "),s("p",[e._v("而在函数式编程里面，思想是利用数学方法来思考问题。阶乘的数学表达式是："),s("code",[e._v("f(n) = n*f(n - 1)")]),e._v(" "),s("code",[e._v("(n > 1)")]),e._v(" ，"),s("code",[e._v("f(n) = 1")]),e._v(" "),s("code",[e._v("(n = 1)")]),e._v(" ，利用递归解决问题。这个过程中基本上没有状态量，只有表达式，也没有赋值语句。")]),e._v(" "),s("p",[e._v("OK，说到这里，对函数式编程有了一个大体的回顾，下面就介绍今天的主角 —— "),s("strong",[e._v("函数响应式编程")])]),e._v(" "),s("h2",{attrs:{id:"正文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[e._v("#")]),e._v(" 正文")]),e._v(" "),s("p",[e._v("从名字上来看，就是多了 "),s("strong",[e._v("响应")]),e._v(" 二字，什么是“响应”？")]),e._v(" "),s("p",[e._v("各位一定不陌生！")]),e._v(" "),s("p",[e._v("简答来说就是：当数据发生变动时，会自动触发告知我们：它发生变化了~")]),e._v(" "),s("p",[e._v("Vue.js 底层不就是这种响应式吗？Vue2 通过 definedProperty 的 getter/setter 收集数据变化（依赖收集）；")]),e._v(" "),s("p",[e._v("当我们在使用 vue 开发时，只要一有绑定的数据发生改变，相关的数据及画面也会跟着变动，而开发者不需要写关于“如何通知发生变化”的代码，只需要关注发生变化时要做什么事，这就是典型的 Reactive Programming（响应编程） 。")]),e._v(" "),s("p",[e._v("所以，可以大致猜到："),s("strong",[e._v("函数响应式编程 =  函数式编程 + 响应编程")])]),e._v(" "),s("p",[e._v("事实上，它也确实如此~")]),e._v(" "),s("p",[e._v("一图胜千言：")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://imagelol.com/image/LgZD6O",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ab64a6f366b43afb3e347dfffd62d3a~tplv-k3u1fbpfcp-zoom-1.image",alt:"LgZD6O.md.png"}}),s("OutboundLink")],1)]),e._v(" "),s("p",[e._v("编程范式关系图（部分）")]),e._v(" "),s("p",[e._v("如图，在声明式编程里，有 2 大家族，分别是函数式编程和数据流编程；数据流编程衍生出响应式编程；而函数响应式编程继承了函数式编程和响应式编程（各自的优点）；")]),e._v(" "),s("ul",[s("li",[e._v("响应式编程能在运行时改变事件源（随时间变化的数据输入）的绑定处理，但数据流编程的组织是一开始就确定了的。")])]),e._v(" "),s("h3",{attrs:{id:"事件流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件流"}},[e._v("#")]),e._v(" 事件流")]),e._v(" "),s("p",[s("strong",[e._v("函数响应式编程（FRP）")]),e._v(" 可以更加有效率地处理事件流，而无需管理状态。")]),e._v(" "),s("p",[e._v("举个栗子🌰")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var a = function (b,c) {\n\n    return b + c \n\n} // a = b + c\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("其中 a 实际代表 b 与 c 之和，如果 b 或 c 持续不断在被改变，如何触发 a 值也跟着变化呢？")]),e._v(" "),s("p",[e._v("也就是说，上述代码只是一种表达式，并没有指定 a 值的变化依赖 b 和 c 。")]),e._v(" "),s("p",[e._v("可以使用 Reactive 响应式思想将值的关系进行绑定：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" //A = B + C\n    var reactiveA = $R(function (b, c) { return b + c });\n    var reactiveB = $R.state(2);\n    var reactiveC = $R.state(1);\n    reactiveA.bindTo(reactiveB, reactiveC);\n\n    reactiveA();   //-> 3\n    reactiveB(5);  //Set reactiveB to 5\n    reactiveC(10); //Set reactiveC to 10\n    reactiveA();   //-> 15\n<p>\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br")])]),s("p",[e._v("b 和 c 可以看成是被观察者，而 a 作为观察者，随着时间推移，b 和 c 的值不断变化，这种变化将传导到 a；")]),e._v(" "),s("p",[e._v("函数响应式编程（FRP）所做的就是：遍历整个事情流集合，将导致 b 和 c 变化的事情回放，并获得 a 的结果；")]),e._v(" "),s("p",[e._v("【事件流】被称为【被观察者序列】(observable sequences)，其实被观察者是一种 Monads。")]),e._v(" "),s("ul",[s("li",[e._v("说明：既然是一种 Monads，就意味着存在延迟计算，即只有当变量真正使用时才去计算，整个链式遍历的过程也是这样。"),s("a",{attrs:{href:"https://juejin.cn/post/7016451477979791396",target:"_blank",rel:"noopener noreferrer"}},[e._v("更多"),s("OutboundLink")],1)])]),e._v(" "),s("h3",{attrs:{id:"rxjs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rxjs"}},[e._v("#")]),e._v(" RxJS")]),e._v(" "),s("p",[e._v("在 JS 中，能体现 FRP 的第三方框架是 "),s("a",{attrs:{href:"https://rxjs.dev/guide/overview",target:"_blank",rel:"noopener noreferrer"}},[e._v("RxJS"),s("OutboundLink")],1),e._v("。借助 RxJS，我们可以感受函数响应式编程大致是怎样的：")]),e._v(" "),s("p",[e._v("在原生 JavaScript 中")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var handler = (e) => {\n\tconsole.log(e);\n\tdocument.body.removeEventListener('click', handler); // 结束监听\n}\n\n// 注册监听\ndocument.body.addEventListener('click', handler);\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("在 RXJS 中：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Rx.Observable\n.fromEvent(document.body, 'click') // 注册监听\n.take(1) // 只取一次\n.subscribe(console.log);\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("ul",[s("li",[e._v("RxJS 是一套由 Observable sequences 来组合 "),s("strong",[e._v("非同步行为")]),e._v(" 和 "),s("strong",[e._v("事件基础")]),e._v(" 程序的 JS 库；可以把 RxJS 理解为处理 非同步行为 的 Lodash。")])]),e._v(" "),s("h3",{attrs:{id:"拖拽实战"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#拖拽实战"}},[e._v("#")]),e._v(" 拖拽实战")]),e._v(" "),s("p",[e._v("再演示一个实战栗子🌰：")]),e._v(" "),s("blockquote",[s("p",[e._v("实现一个简单的拖拽功能；")])]),e._v(" "),s("p",[e._v("拖拽功能，可理解为：对 "),s("code",[e._v("mousedown")]),e._v(", "),s("code",[e._v("mousemove")]),e._v(", "),s("code",[e._v("mouseup")]),e._v(" 等多个事件进行观察，并相应地改变小方块的位置。")]),e._v(" "),s("p",[e._v("首先分析一下，为了相应地移动小方块，我们需要知道的信息有：")]),e._v(" "),s("p",[s("strong",[e._v("1).")]),e._v("  小方块被拖拽时的初始位置；")]),e._v(" "),s("p",[s("strong",[e._v("2).")]),e._v("  小方块在被拖拽着移动时，需要移动到的新位置。")]),e._v(" "),s("p",[e._v("数据流如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("mousedown   : --d----------------------d---------\nmousemove   : -m--m-m-m--m--m---m-m-------m-m-m--\nmouseup     : ---------u---------------------u---\n\ndragUpdate  : ----m-m-m-------------------m-m----\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("问题解析为：在每一次 "),s("code",[e._v("mousedown")]),e._v(" 和 "),s("code",[e._v("mouseup")]),e._v(" 之间触发 "),s("code",[e._v("mousemove")]),e._v(" 时，更新小方块的位置。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 伪代码（核心）\nmousedown.switchMap(() => mousemove.takeUntil(mouseup))\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// RxJS 实现拖拽方块\nconst box = document.getElementById('box')\nconst mouseDown$ = Rx.Observable.fromEvent(box, 'mousedown')\nconst mouseMove$ = Rx.Observable.fromEvent(document, 'mousemove')\nconst mouseUp$ = Rx.Observable.fromEvent(document, 'mouseup')\n\nmouseDown$.map((event) => ({\n  pos: getTranslate(box),\n  event,\n}))\n.switchMap((initialState) => {\n  const initialPos = initialState.pos\n  const { clientX, clientY } = initialState.event\n  return mouseMove$.map((moveEvent) => ({\n    x: moveEvent.clientX - clientX + initialPos.x,\n    y: moveEvent.clientY - clientY + initialPos.y,\n  }))\n  .takeUntil(mouseUp$)\n})\n.subscribe((pos) => {\n  setTranslate(box, pos) // 其中，getTranslate 和 setTranslate 主要作用就是获取和更新小方块的位置\n})\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br")])]),s("p",[s("a",{attrs:{href:"https://codepen.io/jerryzou/pen/XgppaN",target:"_blank",rel:"noopener noreferrer"}},[e._v("codepen 体验地址"),s("OutboundLink")],1)]),e._v(" "),s("p",[e._v("如果是用常见命令式风格 JS 原生写：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("window.onload = function() {\n    var dragCircle = document.getElementById('dragCircle');\n    // 获取鼠标点击时在div中的相对位置\n    dragCircle.onmousedown = function(ev) {\n        var ev = ev || window.event; \n\n        var relaX = ev.clientX - this.offsetLeft;\n        var relaY = ev.clientY - this.offsetTop;\n\n        // 获取当前鼠标位置，减去与div的相对位置得到当前div应该被拖拽的位置\n        document.onmousemove = function(ev) {\n            var ev = ev || window.event;\n            dragCircle.style.left = ev.clientX - relaX + 'px';\n            dragCircle.style.top = ev.clientY - relaY + 'px';\n        };\n        document.onmouseup = function(ev) {\n          var ev = ev || window.event;\n          document.onmousemove = null;\n          document.onmouseup = null;\n         }\n     }\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br")])]),s("p",[s("a",{attrs:{href:"https://codepen.io/BenjaminShih/pen/jBEdGX",target:"_blank",rel:"noopener noreferrer"}},[e._v("codepen 体验地址"),s("OutboundLink")],1)]),e._v(" "),s("p",[e._v("对比二者似乎不难发现：监听事件流的方式更符合对事物变化的通常理解，并且代码的组织方式也更清晰，还有扩展性也更高（有兴趣阅读："),s("a",{attrs:{href:"https://jerryzou.com/posts/rxjs-practice-01/",target:"_blank",rel:"noopener noreferrer"}},[e._v("RxJS 实战篇（一）拖拽"),s("OutboundLink")],1),e._v("，对于拖拽功能还有更多升级操作）；")]),e._v(" "),s("h2",{attrs:{id:"小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),s("p",[e._v("OK，通过本文，我们了解了函数式编程、响应式编程、函数响应式编程的基本概念、特点、以及相互之间的关系；也借助 RxJS 了解了函数响应式编程的代码实现；")]),e._v(" "),s("p",[e._v("后续还将带来更多关于 RxJS 的相关内容~")]),e._v(" "),s("p",[e._v("如果觉得还不错的话，不如点个👍吧 O(∩_∩)O")]),e._v(" "),s("blockquote",[s("p",[e._v("我是掘金安东尼，输出暴露输入，技术洞见生活，再会~~")])]),e._v(" "),s("p",[e._v("参考：")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://ithelp.ithome.com.tw/articles/10186104",target:"_blank",rel:"noopener noreferrer"}},[e._v("30 天精通 RxJS (01)：認識 RxJS"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://halfrost.com/functional_reactive_programming_concept/",target:"_blank",rel:"noopener noreferrer"}},[e._v('函数响应式编程 ( FRP ) 从入门到"放弃"'),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://www.jdon.com/45581",target:"_blank",rel:"noopener noreferrer"}},[e._v("什么是函数响应式编程"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://cn.rx.js.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("RxJS 中文文档"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://jerryzou.com/posts/rxjs-practice-01/",target:"_blank",rel:"noopener noreferrer"}},[e._v("RxJS 实战篇（一）拖拽"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://blog.51cto.com/u_15166492/2707312",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rxjs给应用带来的优势"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);n.default=t.exports}}]);