(window.webpackJsonp=window.webpackJsonp||[]).push([[223],{720:function(s,n,a){"use strict";a.r(n);var e=a(2),t=Object(e.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第9天，"),a("a",{attrs:{href:"https://juejin.cn/post/7099702781094674468",title:"https://juejin.cn/post/7099702781094674468",target:"_blank",rel:"noopener noreferrer"}},[s._v("点击查看活动详情"),a("OutboundLink")],1)]),s._v(" "),a("hr"),s._v(" "),a("p",[s._v("前文，我们已经聊过了：柯里化函数、偏函数，根据高阶函数的定义：")]),s._v(" "),a("blockquote",[a("p",[s._v("高阶函指使用其他函数作为参数、或者返回一个函数作为结果的函数。")])]),s._v(" "),a("p",[s._v("柯里化函数、偏函数，都是妥妥的高阶函数！传入一个原函数，返回一个新函数。新函数继承了原函数的能力，又发展出不同的新能力！！")]),s._v(" "),a("p",[s._v("牛哇牛哇，初级前端开发，用函数封装过程，高级前端开发，用函数封装函数。")]),s._v(" "),a("p",[s._v("本篇再介绍一个新的高阶函数 —— "),a("strong",[s._v("缓存函数")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d691a7029184586afe7286b0a7298d3~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),s._v(" "),a("hr"),s._v(" "),a("p",[s._v("什么是缓存函数？什么情况下需要用到缓存函数？")]),s._v(" "),a("p",[s._v("本篇将用以下这个场景来解释：")]),s._v(" "),a("p",[s._v("比方说，我们这里有一个非常耗时的计算函数：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const calculate = (num)=>{\n    const startTime = new Date()\n    for(let i=0;i<num;i++){} // 大数计算\n    const endTime = new Date()\n    return endTime - startTime\n}\nconsole.log(calculate(10_000_000_000))\n\n// 10465\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("遍历数字 100 亿，需耗时 10s +，打印出这个值；")]),s._v(" "),a("p",[s._v("问："),a("strong",[s._v("有什么办法能够缓存下来这个值，等到下次再次调用 "),a("code",[s._v("calculate(10_000_000_000)")]),s._v(" 的时候，不需要再次进行计算，直接就输出这个计算结果？？")])]),s._v(" "),a("p",[s._v("有人说：着还不简单吗，直接把结果付给一个变量，"),a("code",[s._v("let result = calculate(10_000_000_000)")]),s._v(" ，下次直接拿 "),a("code",[s._v("result")]),s._v("的值不就行了吗？")]),s._v(" "),a("blockquote",[a("p",[s._v("从实现上讲，当然是可以的；不过，从设计模式的角度来讲，就不太ok了！")])]),s._v(" "),a("p",[s._v("为什么？")]),s._v(" "),a("p",[s._v("因为声明 "),a("code",[s._v("result")]),s._v(" 变量作为一个全局变量要一直存在，不管未来你用或者不用，它都存在着，占用着内存；")]),s._v(" "),a("p",[s._v("设想下，如果有 N 个大数的计算，要写 N 个变量去存吗？即使有一些是后面不会再重复被调用了的。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("let result = calculate(10_000_000_000)\nlet result1 = calculate(10_000_000_0000)\n......\nlet resultN = calculate(10_000_000_0000...000)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("又有朋友说了：“我有好主意”！")]),s._v(" "),a("p",[s._v("我直接声明一个缓存对象，再改写 "),a("code",[s._v("calculate")]),s._v(" 函数内部，计算的时候判断一下，算过了的，就从对象里面拿，没算过的，才会进行计算。")]),s._v(" "),a("p",[s._v("代码如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("let cacheObj = {}\n\nconst calculate = (num)=>{\n        if(!cacheObj[num]){\n            const startTime = new Date()\n            for(let i=0;i<num;i++){}\n            const endTime = new Date()\n            cacheObj[num] = endTime - startTime\n        }\n    return cacheObj[num]\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("本瓜不得不说：你这孩子打小就聪明！")]),s._v(" "),a("blockquote",[a("p",[s._v("但是，忘记开闭原则了吗？我们尽量要少修改原函数，而是尽量在其基础上去拓展它。")])]),s._v(" "),a("p",[s._v("这次是 "),a("code",[s._v("calculate")]),s._v(" 函数需要缓存，下次，可能是 "),a("code",[s._v("balculate")]),s._v(" 或 "),a("code",[s._v("dalculate")]),s._v(" ，难道还要去改这些函数的内部判断吗？")]),s._v(" "),a("p",[s._v("当然不！！缓存函数就是来解决这种困境的！！")]),s._v(" "),a("p",[s._v("代码如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("/*\n* 缓存函数 cashed\n*/\n\nfunction cached(fn){ // 传入需要缓存结果的函数\n  \n  const cacheObj = Object.create(null); // 创建一个对象\n  \n  return function cachedFn (str) { // 返回回调函数\n    if ( !cacheObj [str] ) { // 在对象里面查询，函数结果是否被计算过\n        let result = fn(str);\n        cacheObj [str] = result; // 没有则要执行原函数，并把计算结果缓存起来\n    }\n    return cacheObj [str] // 被缓存过，直接返回\n  }\n}\n\n// calculate 计算大数的函数（也可以叫原函数）\nconst calculate = (num)=>{\n    const startTime = new Date()\n    for(let i=0;i<num;i++){}\n\tconst endTime = new Date()\n    return endTime - startTime\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 经过缓存函数 cashed 将原函数 calculate 封装，让原函数具有缓存的新功能\nlet cashedCalculate = cached(calculate)\n\ncashedCalculate(10_000_000_000) // 10465\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("计算结果，就已经被缓存到 "),a("code",[s._v("cashedCalculate")]),s._v(" 里面了，我们再次调用：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("cashedCalculate(10_000_000_000) // 10465\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("会立即得到计算结果 ！")]),s._v(" "),a("hr"),s._v(" "),a("p",[s._v("小结：")]),s._v(" "),a("p",[s._v("哈哈，就是这样巧妙的思路，如果问缓存函数的究极奥义是啥？")]),s._v(" "),a("p",[s._v("本瓜会答：是闭包！闭包太强了，用 cached 函数处理 calculate 的时候，就留下了一个闭包对象 cacheObj ，一直被存储着。并且返回的是回调函数，一样去接收后续的参数。")]),s._v(" "),a("p",[s._v("这样，既避免了多次创建全局变量，也避免了多次修改原函数内部。")]),s._v(" "),a("p",[s._v("用函数封装函数，高级！！")]),s._v(" "),a("blockquote",[a("p",[s._v("OK，以上便是本篇分享。点赞关注评论，为好文助力👍")]),s._v(" "),a("p",[s._v("我是掘金安东尼 🤠 100 万阅读量人气前端技术博主 💥 INFP 写作人格坚持 1000 日更文 ✍ 陪你一起度过漫长岁月 🌏")])])])}),[],!1,null,null,null);n.default=t.exports}}]);