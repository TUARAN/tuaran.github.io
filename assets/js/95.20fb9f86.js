(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{593:function(e,t,s){"use strict";s.r(t);var a=s(2),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"字节码缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字节码缓存"}},[e._v("#")]),e._v(" 字节码缓存")]),e._v(" "),s("p",[s("strong",[e._v("什么是字节码缓存？")])]),e._v(" "),s("p",[s("strong",[s("code",[e._v("字节码缓存（Bytecode Cache）")]),e._v("，是浏览器性能优化机制中重要的一项，通过缓存 解析（pasing）+编译（compilation）的结果，减少网站的启动时间")]),e._v("；当前市面上主流的浏览器都实现了字节码缓存功能；")]),e._v(" "),s("p",[e._v("以 Chrome 为例，V8 早期采用了直接生成二进制机器码的方式，即：")]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("js 源代码 => AST 抽象语法树 => 二进制文件")])])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13dc7791bb5c4ce09ab20de2eb7e4083~tplv-k3u1fbpfcp-zoom-1.image",alt:"image.png"}})]),e._v(" "),s("p",[e._v("虽然当时也采用了二进制代码缓存（缓存到内存和硬盘上）来省去重复编译时间；")]),e._v(" "),s("p",[e._v("但是，二进制代码的问题在于：1. 内存占用大；2. 代码复杂度高；3. 惰性编译只缓存最外层代码；")]),e._v(" "),s("p",[e._v("于是乎，后来 V8 也引进了字节码架构：")]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("js 源代码 => AST 抽象语法树 => 字节码 => 二进制文件")])])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e693453365d4648b6d226fd179aeb04~tplv-k3u1fbpfcp-zoom-1.image",alt:"image.png"}})]),e._v(" "),s("p",[e._v("引入字节码的优势在于：1. 内存占用小；2. 编译快、启动快；3. 降低代码复杂度；")]),e._v(" "),s("p",[e._v("除了 Google，同行 Mozilla 也应用了字节码缓存机制； 更多见官网 blog 介绍： "),s("a",{attrs:{href:"https://blog.mozilla.org/javascript/2017/12/12/javascript-startup-bytecode-cache/",target:"_blank",rel:"noopener noreferrer"}},[e._v("《Mozilla - JavaScript 启动字节码缓存》"),s("OutboundLink")],1)]),e._v(" "),s("p",[s("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/744edef2e9e647e7ad6fc24f6c024c13~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),e._v(" "),s("p",[s("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ae8c963e95e40e8bbb030301e437621~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),e._v(" "),s("p",[e._v("并且还对比了是否启用 JSBC（The JavaScript Startup Bytecode Cache）在主流网站的性能表现统计：")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2829e88d3ed2456ca724bd80b94a2458~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),e._v(" "),s("h2",{attrs:{id:"两级缓存策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两级缓存策略"}},[e._v("#")]),e._v(" 两级缓存策略")]),e._v(" "),s("p",[s("strong",[e._v("正片开启 —— 两级缓存策略！")])]),e._v(" "),s("p",[e._v("实际上，对于 V8 编译后的字节码，Chrome 有两级缓存策略：")]),e._v(" "),s("blockquote",[s("ol",[s("li",[e._v("Isolate 内存缓存；")]),e._v(" "),s("li",[e._v("完整序列化的硬盘缓存；")])])]),e._v(" "),s("p",[s("strong",[e._v("1. Isolate 内存缓存：")])]),e._v(" "),s("p",[e._v("Isolate 缓存发生在同一进程中（同一页面中），它试图尽可能快而小地使用已经可用的数据；")]),e._v(" "),s("p",[e._v("它的劣势在于：a. 命中率偏低（80%）；b. 不能跨进程；")]),e._v(" "),s("p",[e._v("当 V8 编译脚本时，编译后的脚本以源码为键被存储在一个 hashtable 中（在 V8 的堆中），当 Chrome 要求 V8 编译其他脚本的时候，V8 首先检查脚本的源码是否能匹配 hashtable 中的值。如果是，则返回已经存在的字节码。")]),e._v(" "),s("p",[s("strong",[e._v("2. 完整序列化的硬盘缓存：")])]),e._v(" "),s("p",[e._v("硬盘缓存是由 Chrome 管理（准确来说是由 Blink ），它填充了 Isolate 缓存不能在多个进程或多个 Chrome 会话间共享代码缓存的空白。")]),e._v(" "),s("p",[e._v("它利用现有的 HTTP 资源缓存，管理从 Web 接收的缓存和过期数据，具体过程是：")]),e._v(" "),s("p",[s("strong",[e._v("①")]),e._v("  当首次请求一个 JS 文件（即 "),s("strong",[e._v("cold run")]),e._v("）时，Chrome 会下载它并将其交给 V8 进行编译。它还将文件存储在浏览器的磁盘缓存中。")]),e._v(" "),s("p",[s("strong",[e._v("②")]),e._v("  当第二次请求 JS 文件（即 "),s("strong",[e._v("warm run")]),e._v("）时，Chrome 会从浏览器缓存中获取该文件，并再次将其提供给 V8 进行编译。然而，这一次编译的代码被序列化，并作为元数据附加到缓存的脚本文件中。")]),e._v(" "),s("p",[s("strong",[e._v("③")]),e._v("  第三次（即 "),s("strong",[e._v("hot run")]),e._v("），Chrome 从缓存中获取文件和文件的元数据，并将两者交给 V8。V8 反序列化元数据并且可以跳过编译。")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbfdee4ae948405983fe426233e489f8~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),e._v(" "),s("p",[s("sub",[e._v("在 "),s("strong",[e._v("warm run")]),e._v(" 时使用内存缓存，在 "),s("strong",[e._v("hot run")]),e._v(" 时使用磁盘缓存；")])]),e._v(" "),s("h2",{attrs:{id:"再看-http-缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#再看-http-缓存"}},[e._v("#")]),e._v(" 再看 HTTP 缓存")]),e._v(" "),s("p",[s("strong",[e._v("知己知彼、百战不殆！")])]),e._v(" "),s("p",[e._v("根据对【字节码缓存】以及 【两级缓存策略】的认知，我们将有更清晰的思路来利用浏览器缓存机制提升网站的加载性能！")]),e._v(" "),s("p",[e._v("还记得强缓存、协商缓存中的这张图吗？")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d443e19d345b4324a35a2d233e0294cb~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),e._v(" "),s("p",[e._v("当服务器返回 "),s("code",[e._v("304 Not Modified")]),e._v(" 时，我们的字节码缓存保持着 "),s("strong",[e._v("warm run（暖运行）")]),e._v(" 或 "),s("strong",[e._v("hot run（热运行）")]),e._v("；当返回为  "),s("code",[e._v("200 OK")]),e._v(" 时，更新缓存资源，"),s("strong",[e._v("并且清除字节码缓存，恢复到 cold run（冷运行）状态；")]),e._v("（哇！HTTP 缓存文件再进一步的理解！从【文件缓存】到【文件编译后的字节码缓存】的理解~）")]),e._v(" "),s("p",[e._v("所以，"),s("strong",[e._v("减少代码变更")]),e._v("，仍然是利用缓存最基础也是最有效的一条准则；")]),e._v(" "),s("p",[e._v("当然，与之同为一个道理的是："),s("strong",[e._v("不随意修改资源的 URL")]),e._v("，因为字节码缓存与脚本的 URL 关联，修改 URL，会在浏览器的缓存资源中创建一个新的资源入口，并伴随着一个冷缓存入口；")]),e._v(" "),s("p",[e._v("还有 1 个细节就是，我们做 A/B 测试时，也可能出现缓存不同的资源，所以 "),s("strong",[e._v("保证运行的确定性")]),e._v("，也是保证能走对应的缓存的前提：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("if (Math.random() > 0.5) {\n  A();\n} else {\n  B();\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("还有一个老生常谈的 HTTP 缓存策略："),s("strong",[e._v("将稳定的第三方库分离成独立文件")]),e._v("；")]),e._v(" "),s("p",[e._v("通常来说，我们不建议将所有 JS 脚本合并到一个大的 bundle 中，将其分成多个较小脚本往往更有利于除了字节码缓存之外的其他原因（如：多个网络请求、流编译、页面交互等）。")]),e._v(" "),s("p",[e._v("注：字节码缓存的最小文件大小限制是 1 Kb，文件太小也不行；")]),e._v(" "),s("h2",{attrs:{id:"强制编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强制编译"}},[e._v("#")]),e._v(" 强制编译")]),e._v(" "),s("p",[s("strong",[e._v("不过，这里仔细想一想：")])]),e._v(" "),s("p",[e._v("只有在代码执行完成时编译了的代码才会被加入到字节码缓存中，那么有许多类型的函数尽管会稍后执行，但也不会被缓存。如：事件处理程序（甚至是 onload）、promise 链、未使用的库函数和其他一些延迟编译而没有在执行到 "),s("code",[e._v("<\/script>")]),e._v(" 之前被调用的，都会保持延迟而不会被执行，它们是不会作为字节码被缓存；")]),e._v(" "),s("p",[e._v("怎么办？")]),e._v(" "),s("p",[e._v("噢，我们可以通过 "),s("strong",[e._v("立即执行函数")]),e._v("（IIFE）来强制编译它们！")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("(function foo() {\n  // …\n})();\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("因为 IIFE 表达式会被立即调用，大多数 JavaScript 引擎会尝试探测它们并立即编译，然后进行完全编译；")]),e._v(" "),s("p",[e._v("由于探测手段不同，现在，即使函数实际不是立即执行也会被编译，如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const foo = function() {\n  // Lazily skipped\n};\nconst bar = (function() {\n  // Eagerly compiled\n});\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p",[e._v("（秒啊）")]),e._v(" "),s("h2",{attrs:{id:"service-worker-缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#service-worker-缓存"}},[e._v("#")]),e._v(" service worker 缓存")]),e._v(" "),s("p",[s("strong",[e._v("service worker")]),e._v(" 中也有字节码缓存机制；")]),e._v(" "),s("p",[e._v("我们知道 service worker 可以让你构建本地资源缓存，当你发送请求的时候，会从本地缓存提供资源。如果你想构建离线应用，这点特别有用，例如：PWA 应用。")]),e._v(" "),s("p",[e._v("代码示例：")]),e._v(" "),s("ul",[s("li",[e._v("service worker 为安装（创建资源）和获取（从潜在的缓存提供资源）事件添加处理程序。")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// sw.js\nself.addEventListener('install', (event) => {\n  async function buildCache() {\n    const cache = await caches.open(cacheName);\n    return cache.addAll([\n      '/main.css',\n      '/main.mjs',\n      '/offline.html',\n    ]);\n  }\n  event.waitUntil(buildCache());\n});\n\nself.addEventListener('fetch', (event) => {\n  async function cachedFetch(event) {\n    const cache = await caches.open(cacheName);\n    let response = await cache.match(event.request);\n    if (response) return response;\n    response = await fetch(event.request);\n    cache.put(event.request, response.clone());\n    return response;\n  }\n  event.respondWith(cachedFetch(event));\n});\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br")])]),s("p",[e._v("这些缓存包括 JS 资源缓存。但 service worker 的缓存主要用于 PWA，所以它与 Chrome 的“自动”缓存的机制略微不同；")]),e._v(" "),s("p",[e._v("service worker 中，当 JS 资源被添加到缓存的时候，它们立即创建字节码缓存，这意味着"),s("strong",[e._v("在第二次加载的时候字节码缓存是可用的")]),e._v("（而不是像前文所讲的两级缓存一样仅在第三次加载的时可用）；")]),e._v(" "),s("p",[e._v("其次，service worker 为这些脚本生成了 "),s("strong",[e._v("“全量”字节码缓存")]),e._v("，不存在有延迟编译，而是全部编译好放到缓存中。这具有快速且可预测的性能的优点，没有执行顺序依赖性，但是这以增加的内存使用为代价；")]),e._v(" "),s("p",[e._v("请注意，此策略仅适用于 service worker 缓存，而不适用于 Cache API 的其他用途。实际上，现在的 Cache API 不会执行字节码缓存。")]),e._v(" "),s("h2",{attrs:{id:"阶段小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#阶段小结"}},[e._v("#")]),e._v(" 阶段小结")]),e._v(" "),s("p",[e._v("以上，本文先讲了"),s("strong",[e._v("什么是字节码")]),e._v("，然后讲了"),s("strong",[e._v("字节码的两级缓存策略")]),e._v("，再讲了"),s("strong",[e._v("从字节码的缓存机制中看 HTTP 缓存")]),e._v("，给到对应的建议及不同角度的理解（核心）；再讲了一个细节："),s("strong",[e._v("强制编译")]),e._v("；最后讲了在 "),s("strong",[e._v("service worker 缓存")]),e._v("中，字节码缓存的差异；")]),e._v(" "),s("p",[e._v("对于一部分开发人员来讲，缓存啥的，能用就行，性能啥的，loading 就行；但是认真去了解浏览器的内部一些机制后，会发现：我们之所以站的这么高，是因为踩在了巨人的肩膀上！")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47ef374a9e33436e93da4b23151fe5e3~tplv-k3u1fbpfcp-watermark.image?",alt:"06b9e718.gif"}})]),e._v(" "),s("p",[e._v("ok，打完收工！这一波，够细节！！")]),e._v(" "),s("blockquote",[s("p",[e._v("撰文不易，点赞鼓励 👍👍👍👍👍👍")]),e._v(" "),s("p",[e._v("我是掘金安东尼，公众号同名，输出暴露输入，技术洞见生活，再会~")])]),e._v(" "),s("h2",{attrs:{id:"参考文献"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[e._v("#")]),e._v(" 参考文献")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://blog.mozilla.org/javascript/2017/12/12/javascript-startup-bytecode-cache/",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript Startup Bytecode Cache"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://v8.dev/blog/code-caching-for-devs",target:"_blank",rel:"noopener noreferrer"}},[e._v("Code caching for JavaScript developers"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://bugs.webkit.org/show_bug.cgi?id=192782",target:"_blank",rel:"noopener noreferrer"}},[e._v("Bug 19278 - JSC Cache bytecode to disk"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://juejin.cn/post/6844904152745639949",target:"_blank",rel:"noopener noreferrer"}},[e._v("V8 引擎详解"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=r.exports}}]);