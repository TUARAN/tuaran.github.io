(window.webpackJsonp=window.webpackJsonp||[]).push([[227],{726:function(e,t,n){"use strict";n.r(t);var s=n(2),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第12天，"),n("a",{attrs:{href:"https://juejin.cn/post/7099702781094674468",target:"_blank",rel:"noopener noreferrer"}},[e._v("点击查看活动详情"),n("OutboundLink")],1)]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("JavaScript 高级程序设计第 4 版（后简称高程4），相较于第 3 版，增加了 ES6 至 ES10 的全新内容，删除了旧版过时的内容，并在原有基础上充实了更加翔实的内容。")]),e._v(" "),n("p",[e._v("中文译版于 2020 年发售，妥妥的“新鲜出炉”，你要是问本瓜："),n("strong",[e._v("当今学 JavaScript 哪家强，我只能说：红宝书第 4 版最在行。")])]),e._v(" "),n("p",[e._v("于是乎，借着更文契机，本瓜将开启一个小系列，带你重看一遍高级程序设计4（先前只是跳着跳着看），将抽取精华，用最简单的话解释核心点、尽量把握全局、快速过一遍的同时，记录与工友们分享~~")]),e._v(" "),n("h3",{attrs:{id:"正文"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[e._v("#")]),e._v(" 正文")]),e._v(" "),n("p",[e._v("第七章，也是本瓜最感兴趣的一章之一 —— 《迭代器与生成器》（JavaScript 的延迟计算依赖的就是它），是重点毋庸置疑了。")]),e._v(" "),n("blockquote",[n("p",[e._v("ECMAScript 6 规范新增了两个高级特性：迭代器和生成器。使用这两个特性，能够更清晰、高效、方便地实现迭代。")])]),e._v(" "),n("p",[n("strong",[e._v("本篇先只讲：迭代器，以及 for、forEach、for…in、for…of 的区别。")])]),e._v(" "),n("p",[e._v("奥利给，冲！！")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("先回想，咱们以前是怎么去迭代的？")]),e._v(" "),n("p",[e._v("通常大部分情况下都是迭代数组吧？！")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let arr = [1,2,3]\nfor (let index = 0; index < arr.length; index++) {\n  console.log(arr[index]);\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])]),n("p",[e._v("通过 for 循环去迭代，有什么问题吗？高程给出了解释：")]),e._v(" "),n("ol",[n("li",[n("strong",[e._v("迭代之前需要事先知道如何使用数据结构。")]),e._v(" 数组中的每一项都只能先通过引用取得数组对象， 然后再通过[]操作符取得特定索引位置上的项。并且，这种情况并不适用于所有数据结构。")]),e._v(" "),n("li",[n("strong",[e._v("遍历顺序并不是数据结构固有的。")]),e._v(" 通过递增索引来访问数据是特定于数组类型的方式，并不适 用于其他具有隐式顺序的数据结构。")])]),e._v(" "),n("p",[e._v("什么意思？即： for 循环不适用遍历所有数据结构；")]),e._v(" "),n("p",[e._v("ES5 发布了 "),n("code",[e._v("forEach")]),e._v(" ，并没有做出任何改善，反而也是弊端多多：")]),e._v(" "),n("ol",[n("li",[e._v("不能使用 break 语句中断循环；")]),e._v(" "),n("li",[e._v("不能使用 "),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1),e._v("return 语句返回到外层函数；")])]),e._v(" "),n("p",[n("code",[e._v("for-in")]),e._v(" 呢？for-in 是为遍历普通对象设计的，可以得到字符串类型的键，不适用于数组遍历。")]),e._v(" "),n("p",[n("code",[e._v("for-of")]),e._v(" 呢？没错，它是今天的主角！")]),e._v(" "),n("p",[n("strong",[e._v("for-of 循环语句通过方法调用来遍历各种集合：数组、NodeList、字符串、Maps 对象、Sets 对象等等")])]),e._v(" "),n("p",[e._v("这些对象都有一个共通的特点：它们都有一个迭代器方法！")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let str = 'abc';\nlet arr = ['a', 'b', 'c'];\nlet map = new Map().set('a', 1).set('b', 2).set('c', 3);\nlet set = new Set().add('a').add('b').add('c');\nlet els = document.querySelectorAll('div');\n\n// 这些类型都实现了迭代器工厂函数\nconsole.log(str[Symbol.iterator]); // f values() { [native code] }\nconsole.log(arr[Symbol.iterator]); // f values() { [native code] }\nconsole.log(map[Symbol.iterator]); // f values() { [native code] }\nconsole.log(set[Symbol.iterator]); // f values() { [native code] }\nconsole.log(els[Symbol.iterator]); // f values() { [native code] }\n\n// 调用这个工厂函数会生成一个迭代器\nconsole.log(str[Symbol.iterator]()); // StringIterator {}\nconsole.log(arr[Symbol.iterator]()); // ArrayIterator {}\nconsole.log(map[Symbol.iterator]()); // MapIterator {}\nconsole.log(set[Symbol.iterator]()); // SetIterator {}\nconsole.log(els[Symbol.iterator]()); // ArrayIterator {}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br"),n("span",{staticClass:"line-number"},[e._v("16")]),n("br"),n("span",{staticClass:"line-number"},[e._v("17")]),n("br"),n("span",{staticClass:"line-number"},[e._v("18")]),n("br"),n("span",{staticClass:"line-number"},[e._v("19")]),n("br")])]),n("p",[e._v("ES6 默认的 Iterator 接口部署在数据结构的 "),n("code",[e._v("Symbol.iterator")]),e._v("属性上，该属性本身是一个函数，代表当前数据结构默认的遍历器生成函数。执行该函数 "),n("code",[e._v("[Symbol.iterator]()")]),e._v("，会返回一个遍历器对象。只要数据结构拥有 "),n("code",[e._v("Symbol.iterator")]),e._v("属性，那么它就是 “可遍历的” 。")]),e._v(" "),n("p",[e._v("原生具备 Iterator 接口的数据结构：")]),e._v(" "),n("ul",[n("li",[e._v("Array")]),e._v(" "),n("li",[e._v("Map")]),e._v(" "),n("li",[e._v("Set")]),e._v(" "),n("li",[e._v("String")]),e._v(" "),n("li",[e._v("TypedArray")]),e._v(" "),n("li",[e._v("函数的 arguments 对象")]),e._v(" "),n("li",[e._v("NodeList 对象")])]),e._v(" "),n("p",[e._v("它们其实就是默认的迭代器对象。")]),e._v(" "),n("hr"),e._v(" "),n("p",[n("strong",[e._v("所有拥有 Symbol.iterator 的对象被称为可迭代的。")])]),e._v(" "),n("p",[n("code",[e._v("for...of")]),e._v(" 运行原理：")]),e._v(" "),n("ol",[n("li",[e._v("首先调用遍历对象 "),n("code",[e._v("[Symobo.iterator]()")]),e._v(" 方法，拿到遍历器对象;")]),e._v(" "),n("li",[e._v("每次循环，调用遍历器对象 "),n("code",[e._v("next()")]),e._v(" 方法，得到 "),n("code",[e._v("{value: ..., done: ... }")]),e._v(" 对象")])]),e._v(" "),n("p",[n("code",[e._v(".next()")]),e._v(" 方法，返回："),n("code",[e._v("value")]),e._v(" 和 "),n("code",[e._v("done")]),e._v("，如果 "),n("code",[e._v("done")]),e._v(" 为 true，则代表：迭代已完成；")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let arr = ['foo', 'bar'];\nlet iter = arr[Symbol.iterator]();\n\nconsole.log(iter.next()); // { done: false, value: 'foo' }\nconsole.log(iter.next()); // { done: false, value: 'bar' }\nconsole.log(iter.next()); // { done: true, value: undefined }\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br")])]),n("p",[e._v("我们可以尝试自己写一个极简版的迭代器对象：")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Counter {\n\t // Counter 的实例应该迭代 limit 次\n\t constructor(limit) {\n\t\tthis.count = 1;\n\t\tthis.limit = limit;\n\t }\n\t next() {\n\t\t if (this.count <= this.limit) {\n\t\t\t\t return { done: false, value: this.count++ };\n\t\t } else {\n\t\t\t\t return { done: true, value: undefined };\n\t\t }\n\t }\n\t [Symbol.iterator]() {\n\t\t return this;\n\t }\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br"),n("span",{staticClass:"line-number"},[e._v("16")]),n("br"),n("span",{staticClass:"line-number"},[e._v("17")]),n("br")])]),n("p",[e._v("很神奇，不是吗？")]),e._v(" "),n("p",[e._v("咱就是说 ES6 为啥要搞一个迭代器呢，或者说迭代器的优势在哪里？")]),e._v(" "),n("blockquote",[n("p",[e._v("JavaScript 中 原有表示 “集合” 的数据结构主要是 “数组(Array)” 和 “对象(Object)”，ES6又新增了 "),n("code",[e._v("Map")]),e._v("和 "),n("code",[e._v("Set")]),e._v("，共四种数据集合，浏览器端还有 "),n("code",[e._v("NodeList")]),e._v("类数组结构。为 “集合” 型数据寻求统一的遍历接口，正是 ES6 的 Iterator 诞生的背景。")])]),e._v(" "),n("p",[n("strong",[e._v("目的就是为了：统一！统一各种类型的集合，给出一种通用的、底层的迭代方案！")])]),e._v(" "),n("p",[e._v("迭代器是一种设计模式，为遍历不同数据结构的 “集合” 提供统一的接口；能遍历访问 “集合” 数据中的项，不关心项的数据结构。")]),e._v(" "),n("blockquote",[n("p",[e._v("OK，以上便是本篇分享。 觉得不错点个赞吧👍👍👍，您的鼓励，我的动力，坚持原创质量好文~~ 欢迎评论留言 我是掘金安东尼，输出暴露输入，技术洞见生活。再会吧~~ 👋👋👋")])])])}),[],!1,null,null,null);t.default=a.exports}}]);